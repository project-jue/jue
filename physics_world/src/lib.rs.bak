pub mod distributed;
pub mod memory;
pub mod scheduler;
pub mod types;
pub mod vm;

use serde::Serialize;
use std::collections::HashSet;
use std::fmt;

// Re-export commonly used types for easier access
pub use distributed::DistributedScheduler;
pub use scheduler::{Actor, CapDecision, PhysicsScheduler, TickResult};
pub use types::{Capability, HostFunction, OpCode, Value};
pub use vm::state::VmState;

/// The main entry point for the Physics World public API.
/// This is the immutable, external interface for Jue-World.
pub struct PhysicsWorld {
    scheduler: PhysicsScheduler,
}

impl PhysicsWorld {
    /// Creates a new PhysicsWorld with an empty scheduler.
    pub fn new() -> Self {
        Self {
            scheduler: PhysicsScheduler::new(),
        }
    }

    /// Executes an actor's code with strict resource limits.
    ///
    /// # Arguments
    /// * `actor_id` - The ID of the actor to execute
    /// * `bytecode` - The compiled bytecode to execute
    /// * `constants` - The constant pool for the bytecode
    /// * `step_limit` - Maximum number of execution steps allowed
    /// * `memory_limit` - Maximum memory allocation allowed in bytes
    ///
    /// # Returns
    /// An `ExecutionResult` containing the output, messages, errors, and resource metrics
    pub fn execute_actor(
        &mut self,
        actor_id: u32,
        bytecode: Vec<OpCode>,
        constants: Vec<Value>,
        step_limit: u64,
        memory_limit: usize,
    ) -> ExecutionResult {
        // Create a new VM state for the actor
        let vm_state = VmState::new(bytecode, constants, step_limit, memory_limit, actor_id);

        // Create the actor with V2 capability fields and priority fields
        let actor = Actor {
            id: actor_id,
            vm: vm_state,
            mailbox: Vec::new(),
            is_waiting: false,
            capabilities: HashSet::new(),
            capability_requests: Vec::new(),
            parent_id: None,
            priority: 128, // Default priority
            priority_boost: None,
        };

        // Add the actor to the scheduler
        self.scheduler.add_actor(actor);

        // Execute the actor until completion or error
        let messages_sent = Vec::new();
        let mut output = None;
        let mut error = None;
        let mut steps_used = 0;
        let memory_used = 0;

        loop {
            match self.scheduler.tick() {
                Ok(tick_result) => {
                    match tick_result {
                        TickResult::ActorYielded(_) => {
                            // Actor yielded, but we'll continue execution
                            steps_used += 1;
                            continue;
                        }
                        TickResult::ActorFinished(_, value) => {
                            output = Some(value);
                            steps_used += 1; // Count the final step
                            break;
                        }
                        TickResult::ActorErrored(_, vm_error) => {
                            steps_used += 1; // Count the error step
                                             // Convert VM error to structured error
                            error = Some(match vm_error {
                                vm::error::VmError::CpuLimitExceeded { limit, .. } => {
                                    StructuredError::CpuLimitExceeded {
                                        limit,
                                        attempted: steps_used,
                                    }
                                }
                                vm::error::VmError::MemoryLimitExceeded { limit, .. } => {
                                    StructuredError::MemoryLimitExceeded {
                                        limit,
                                        attempted: memory_used,
                                    }
                                }
                                vm::error::VmError::StackUnderflow { .. } => {
                                    StructuredError::StackUnderflow
                                }
                                vm::error::VmError::InvalidHeapPtr { .. } => {
                                    StructuredError::InvalidHeapPtr
                                }
                                vm::error::VmError::UnknownOpCode { .. } => {
                                    StructuredError::UnknownOpCode
                                }
                                vm::error::VmError::TypeMismatch { .. } => {
                                    StructuredError::TypeMismatch
                                }
                                vm::error::VmError::DivisionByZero { .. } => {
                                    StructuredError::DivisionByZero
                                }
                                vm::error::VmError::ArithmeticOverflow { .. } => {
                                    StructuredError::ArithmeticOverflow
                                }
                                vm::error::VmError::CapabilityError { capability, .. } => {
                                    StructuredError::CapabilityError(format!(
                                        "Capability error: {}",
                                        capability
                                    ))
                                }
                                vm::error::VmError::SerializationError { message, .. } => {
                                    StructuredError::SchedulerError(format!(
                                        "Serialization error: {}",
                                        message
                                    ))
                                }
                                vm::error::VmError::HeapCorruption { message, .. } => {
                                    StructuredError::SchedulerError(format!(
                                        "Heap corruption: {}",
                                        message
                                    ))
                                }
                            });
                            break;
                        }
                        TickResult::ActorWaitingForCapability(actor_id, capability) => {
                            // Handle capability request
                            let decision = self.scheduler.handle_capability_request(
                                actor_id,
                                capability,
                                "Requested during execution",
                            );

                            match decision {
                                CapDecision::Granted => {
                                    // Capability granted, continue execution
                                    continue;
                                }
                                CapDecision::Denied => {
                                    // Capability denied, return error
                                    error = Some(StructuredError::CapabilityError(
                                        "Capability request denied".to_string(),
                                    ));
                                    break;
                                }
                                CapDecision::PendingConsensus => {
                                    // Capability pending consensus, yield and wait
                                    steps_used += 1;
                                    return ExecutionResult {
                                        output: None,
                                        messages_sent,
                                        error: Some(StructuredError::CapabilityError(
                                            "Capability request pending consensus".to_string(),
                                        )),
                                        final_state_snapshot: Vec::new(),
                                        metrics: ResourceMetrics {
                                            steps_used,
                                            memory_used,
                                            execution_time_ms: 0,
                                        },
                                    };
                                }
                            }
                        }
                    }
                }
                Err(physics_error) => {
                    error = Some(StructuredError::SchedulerError(physics_error.to_string()));
                    break;
                }
            }
        }

        // Get the final state of the actor for serialization
        let final_state_snapshot =
            if let Some(actor) = self.scheduler.actors.iter().find(|a| a.id == actor_id) {
                // Serialize the VM state (simplified for now)
                bincode::serialize(&actor.vm).unwrap_or_default()
            } else {
                Vec::new()
            };

        ExecutionResult {
            output,
            messages_sent,
            error,
            final_state_snapshot,
            metrics: ResourceMetrics {
                steps_used,
                memory_used,
                execution_time_ms: 0, // Would be measured in real implementation
            },
        }
    }

    /// Injects messages for an actor to process on its next turn.
    ///
    /// # Arguments
    /// * `actor_id` - The ID of the actor to receive messages
    /// * `messages` - The messages to deliver to the actor
    pub fn deliver_messages(&mut self, actor_id: u32, messages: Vec<Value>) {
        self.scheduler.send_message(actor_id, Value::Nil); // Placeholder for message delivery
                                                           // In a real implementation, we would properly deliver all messages
        for message in messages {
            self.scheduler.send_message(actor_id, message);
        }
        self.scheduler.deliver_external_messages();
    }

    /// V2 Capability System - Execute code at compile-time with restricted capabilities
    /// This is the main comptime execution API that the Jue World compiler calls
    /// for macro expansion and compile-time code evaluation.
    pub fn execute_comptime(
        &mut self,
        bytecode: Vec<OpCode>,
        constants: Vec<Value>,
        env: ComptimeEnv, // Capabilities granted by compiler
    ) -> Result<ComptimeResult, ComptimeError> {
        // Create a temporary actor with COMPTIME capabilities only
        let mut temp_actor = Actor {
            id: COMPTIME_ACTOR_ID,
            vm: VmState::new(
                bytecode,
                constants,
                env.max_steps,
                env.memory_limit,
                COMPTIME_ACTOR_ID,
            ),
            capabilities: env.capabilities,
            mailbox: Vec::new(),
            is_waiting: false,
            capability_requests: Vec::new(),
            parent_id: None,
            priority: 200, // High priority for comptime execution
            priority_boost: None,
        };

        // Run with special comptime scheduler
        let result = self.run_comptime_actor(&mut temp_actor);

        // Comptime execution can't send messages or affect real actors
        // But it can return:
        // 1. Expanded code (new bytecode)
        // 2. Computed constants
        // 3. Proof obligations (for formal tier)
        result
    }

    /// Internal method to run a comptime actor with sandboxed execution
    fn run_comptime_actor(&mut self, actor: &mut Actor) -> Result<ComptimeResult, ComptimeError> {
        // Add the comptime actor to the scheduler
        // We need to take ownership and move the actor into the scheduler
        // Since Actor doesn't implement Clone, we'll use a different approach
        let actor_to_add = std::mem::replace(actor, Actor {
            id: COMPTIME_ACTOR_ID,
            vm: VmState::new(Vec::new(), Vec::new(), 0, 0, COMPTIME_ACTOR_ID),
            capabilities: HashSet::new(),
            mailbox: Vec::new(),
            is_waiting: false,
            capability_requests: Vec::new(),
            parent_id: None,
            priority: 128,
            priority_boost: None,
        });
        self.scheduler.add_actor(actor_to_add);

        // Execute the actor with strict resource limits
        let mut steps_used = 0;
        let mut memory_used = 0;

        loop {
            match self.scheduler.tick() {
                Ok(tick_result) => {
                    match tick_result {
                        TickResult::ActorYielded(_) => {
                            steps_used += 1;
                            continue;
                        }
                        TickResult::ActorFinished(_, value) => {
                            steps_used += 1;
                            // Comptime execution completed successfully
                            return Ok(ComptimeResult {
                                output: Some(value),
                                expanded_code: None,
                                computed_constants: Vec::new(),
                                proof_obligations: Vec::new(),
                                metrics: ResourceMetrics {
                                    steps_used,
                                    memory_used,
                                    execution_time_ms: 0,
                                },
                            });
                        }
                        TickResult::ActorErrored(_, vm_error) => {
                            steps_used += 1;
                            // Convert VM error to comptime error
                            let error = match vm_error {
                                vm::error::VmError::CpuLimitExceeded { limit, .. } => {
                                    ComptimeError::CpuLimitExceeded {
                                        limit,
                                        attempted: steps_used,
                                    }
                                }
                                vm::error::VmError::MemoryLimitExceeded { limit, .. } => {
                                    ComptimeError::MemoryLimitExceeded {
                                        limit,
                                        attempted: memory_used,
                                    }
                                }
                                vm::error::VmError::StackUnderflow { .. } => {
                                    ComptimeError::StackUnderflow
                                }
                                vm::error::VmError::InvalidHeapPtr { .. } => {
                                    ComptimeError::InvalidHeapPtr
                                }
                                vm::error::VmError::UnknownOpCode { .. } => {
                                    ComptimeError::UnknownOpCode
                                }
                                vm::error::VmError::TypeMismatch { .. } => {
                                    ComptimeError::TypeMismatch
                                }
                                vm::error::VmError::DivisionByZero { .. } => {
                                    ComptimeError::DivisionByZero
                                }
                                vm::error::VmError::ArithmeticOverflow { .. } => {
                                    ComptimeError::ArithmeticOverflow
                                }
                                vm::error::VmError::CapabilityError { capability, .. } => {
                                    ComptimeError::CapabilityError(format!(
                                        "Capability error: {}",
                                        capability
                                    ))
                                }
                                vm::error::VmError::SerializationError { message, .. } => {
                                    ComptimeError::SchedulerError(format!(
                                        "Serialization error: {}",
                                        message
                                    ))
                                }
                                vm::error::VmError::HeapCorruption { message, .. } => {
                                    ComptimeError::SchedulerError(format!(
                                        "Heap corruption: {}",
                                        message
                                    ))
                                }
                            };
                            return Err(error);
                        }
                        TickResult::ActorWaitingForCapability(actor_id, capability) => {
                            // Comptime actors cannot request additional capabilities
                            // This is a security measure to prevent capability escalation
                            return Err(ComptimeError::CapabilityError(
                                "Comptime execution cannot request additional capabilities"
                                    .to_string(),
                            ));
                        }
                    }
                }
                Err(physics_error) => {
                    return Err(ComptimeError::SchedulerError(physics_error.to_string()));
                }
            }
        }
    }
}

/// Special actor ID for comptime execution
const COMPTIME_ACTOR_ID: u32 = 0;

/// Comptime execution environment with capabilities and resource limits
#[derive(Debug, Clone)]
pub struct ComptimeEnv {
    /// Capabilities available at compile-time
    pub capabilities: HashSet<Capability>,
    /// Maximum execution steps to prevent infinite compilation
    pub max_steps: u64,
    /// Maximum memory allocation for comptime execution
    pub memory_limit: usize,
}

/// Result type for comptime execution
#[derive(Debug, Serialize)]
pub struct ComptimeResult {
    /// The computed result (if execution completed successfully)
    pub output: Option<Value>,
    /// Expanded code generated by macro execution (new bytecode)
    pub expanded_code: Option<Vec<OpCode>>,
    /// Computed constants for code generation
    pub computed_constants: Vec<Value>,
    /// Proof obligations for formal tier verification
    pub proof_obligations: Vec<String>,
    /// Resource usage metrics for the comptime execution
    pub metrics: ResourceMetrics,
}

/// Error types specific to comptime execution
#[derive(Debug, Serialize)]
pub enum ComptimeError {
    /// CPU step limit was exceeded during comptime execution
    CpuLimitExceeded { limit: u64, attempted: u64 },
    /// Memory limit was exceeded during comptime execution
    MemoryLimitExceeded { limit: usize, attempted: usize },
    /// Stack underflow occurred during comptime execution
    StackUnderflow,
    /// Invalid heap pointer was encountered during comptime execution
    InvalidHeapPtr,
    /// Unknown opcode was encountered during comptime execution
    UnknownOpCode,
    /// Type mismatch occurred during comptime execution
    TypeMismatch,
    /// Division by zero occurred during comptime execution
    DivisionByZero,
    /// Arithmetic overflow occurred during comptime execution
    ArithmeticOverflow,
    /// Scheduler-level error occurred during comptime execution
    SchedulerError(String),
    /// Capability-related error occurred during comptime execution
    CapabilityError(String),
}

impl fmt::Display for ComptimeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ComptimeError::CpuLimitExceeded { limit, attempted } => {
                write!(
                    f,
                    "Comptime CPU limit exceeded: attempted {} steps, limit was {}",
                    attempted, limit
                )
            }
            ComptimeError::MemoryLimitExceeded { limit, attempted } => {
                write!(
                    f,
                    "Comptime memory limit exceeded: attempted {} bytes, limit was {}",
                    attempted, limit
                )
            }
            ComptimeError::StackUnderflow => write!(f, "Comptime stack underflow"),
            ComptimeError::InvalidHeapPtr => write!(f, "Comptime invalid heap pointer"),
            ComptimeError::UnknownOpCode => write!(f, "Comptime unknown opcode"),
            ComptimeError::TypeMismatch => write!(f, "Comptime type mismatch"),
            ComptimeError::DivisionByZero => write!(f, "Comptime division by zero"),
            ComptimeError::ArithmeticOverflow => write!(f, "Comptime arithmetic overflow"),
            ComptimeError::SchedulerError(msg) => write!(f, "Comptime scheduler error: {}", msg),
            ComptimeError::CapabilityError(msg) => write!(f, "Comptime capability error: {}", msg),
        }
    }
}

/// Final output type for actor execution.
#[derive(Serialize)]
pub struct ExecutionResult {
    /// The actor's final result (if execution completed successfully)
    pub output: Option<Value>,
    /// Outbound messages sent by the actor during execution
    pub messages_sent: Vec<(u32, Value)>,
    /// If execution failed, contains the structured error
    pub error: Option<StructuredError>,
    /// Serialized snapshot of the final VM state
    pub final_state_snapshot: Vec<u8>,
    /// Resource usage metrics for the execution
    pub metrics: ResourceMetrics,
}

/// Resource usage metrics for actor execution.
#[derive(Serialize, Debug)]
pub struct ResourceMetrics {
    /// Number of execution steps used
    pub steps_used: u64,
    /// Memory used in bytes
    pub memory_used: usize,
    /// Execution time in milliseconds
    pub execution_time_ms: u64,
}

/// Structured error types that can occur during execution.
#[derive(Serialize)]
pub enum StructuredError {
    /// CPU step limit was exceeded
    CpuLimitExceeded { limit: u64, attempted: u64 },
    /// Memory limit was exceeded
    MemoryLimitExceeded { limit: usize, attempted: usize },
    /// Stack underflow occurred
    StackUnderflow,
    /// Invalid heap pointer was encountered
    InvalidHeapPtr,
    /// Unknown opcode was encountered
    UnknownOpCode,
    /// Type mismatch occurred
    TypeMismatch,
    /// Division by zero occurred
    DivisionByZero,
    /// Arithmetic overflow occurred
    ArithmeticOverflow,
    /// Scheduler-level error occurred
    SchedulerError(String),
    /// Capability-related error occurred
    CapabilityError(String),
}

impl fmt::Display for StructuredError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            StructuredError::CpuLimitExceeded { limit, attempted } => {
                write!(
                    f,
                    "CPU limit exceeded: attempted {} steps, limit was {}",
                    attempted, limit
                )
            }
            StructuredError::MemoryLimitExceeded { limit, attempted } => {
                write!(
                    f,
                    "Memory limit exceeded: attempted {} bytes, limit was {}",
                    attempted, limit
                )
            }
            StructuredError::StackUnderflow => write!(f, "Stack underflow"),
            StructuredError::InvalidHeapPtr => write!(f, "Invalid heap pointer"),
            StructuredError::UnknownOpCode => write!(f, "Unknown opcode"),
            StructuredError::TypeMismatch => write!(f, "Type mismatch"),
            StructuredError::DivisionByZero => write!(f, "Division by zero"),
            StructuredError::ArithmeticOverflow => write!(f, "Arithmetic overflow"),
            StructuredError::SchedulerError(msg) => write!(f, "Scheduler error: {}", msg),
            StructuredError::CapabilityError(msg) => write!(f, "Capability error: {}", msg),
        }
    }
}

impl fmt::Debug for StructuredError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self)
    }
}

#[cfg(test)]
#[path = "test/lib_tests.rs"]
mod tests;