use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fmt;

// A strongly-typed index into an ObjectArena's storage vector.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct HeapPtr(pub u32);

impl HeapPtr {
    pub fn new(ptr: u32) -> Self {
        Self(ptr)
    }

    pub fn get(&self) -> u32 {
        self.0
    }
}

impl fmt::Display for HeapPtr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "HeapPtr({})", self.0)
    }
}

// Represents a compiled instruction.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum OpCode {
    // Constants
    Nil,
    Bool(bool),
    Int(i64),
    Symbol(usize),
    // Primitive Stack Operations
    Swap, // Swap top two stack values
    Dup,
    Pop,
    // Variable Access
    GetLocal(u16), // Get local variable at stack offset
    SetLocal(u16), // Set local variable at stack offset
    // Heap
    Cons,
    Car,
    Cdr,
    // Control
    Call(u16), // Argument count
    Ret,
    Jmp(i16),
    JmpIfFalse(i16),
    // Actors
    Yield,
    Send,
    // Closure Operations
    MakeClosure(usize /* code_idx */, usize /* capture_count */),
    // Resource Management
    CheckStepLimit,

    // Primitive Arithmetic (Int64)
    Add, // TOS = TOS + TOS-1
    Sub, // TOS = TOS - TOS-1
    Mul,
    Div,
    Mod,

    // Primitive Comparisons (result is Bool)
    Eq, // TOS == TOS-1 ?
    Lt, // TOS < TOS-1 ?
    Gt,

    // --- CAPABILITY INSTRUCTIONS ---
    /// Check if actor has capability. Pushes bool to stack.
    /// Operand: index into constant pool where Capability is stored
    HasCap(usize),

    /// Request a capability from scheduler. Blocks until decision.
    /// Operand: capability index, justification string index
    RequestCap(usize, usize),

    /// Grant a capability to another actor.
    /// Requires MetaGrant capability.
    /// Operand: target actor ID, capability index
    GrantCap(u32, usize),

    /// Revoke a capability (from self or other with MetaGrant).
    /// Operand: target actor ID, capability index
    RevokeCap(u32, usize),

    /// Execute a privileged host call.
    /// Requires specific capability (encoded in constant pool).
    /// Format: HostCall { cap_index, function_id, arg_count }
    HostCall {
        cap_idx: usize,
        func_id: u16,
        args: u8,
    },
}

impl OpCode {
    pub fn size_bytes(&self) -> usize {
        match self {
            OpCode::Nil => 1,
            OpCode::Bool(_) => 2,
            OpCode::Int(_) => 9,
            OpCode::Symbol(_) => 5,
            OpCode::Dup => 1,
            OpCode::Pop => 1,
            OpCode::Swap => 1,
            OpCode::GetLocal(_) => 3, // u16 (2 bytes) + opcode tag (1 byte)
            OpCode::SetLocal(_) => 3, // u16 (2 bytes) + opcode tag (1 byte)
            OpCode::Cons => 1,
            OpCode::Car => 1,
            OpCode::Cdr => 1,
            OpCode::Call(_) => 3,
            OpCode::Ret => 1,
            OpCode::Jmp(_) => 3,
            OpCode::JmpIfFalse(_) => 3,
            OpCode::Yield => 1,
            OpCode::Send => 1,
            OpCode::Add => 1,
            OpCode::Sub => 1,
            OpCode::Mul => 1,
            OpCode::Div => 1,
            OpCode::Mod => 1,
            OpCode::Eq => 1,
            OpCode::Lt => 1,
            OpCode::Gt => 1,
            OpCode::MakeClosure(_, _) => 9, // 4 bytes for each usize
            OpCode::CheckStepLimit => 1,
            // Capability instructions
            OpCode::HasCap(_) => 5, // usize (4 bytes) + opcode tag (1 byte)
            OpCode::RequestCap(_, _) => 9, // 2 x usize (8 bytes) + opcode tag (1 byte)
            OpCode::GrantCap(_, _) => 6, // u32 (4 bytes) + usize (4 bytes) + opcode tag (1 byte) = 9 bytes
            OpCode::RevokeCap(_, _) => 6, // u32 (4 bytes) + usize (4 bytes) + opcode tag (1 byte) = 9 bytes
            OpCode::HostCall {
                cap_idx: _,
                func_id: _,
                args: _,
            } => 7, // usize (4) + u16 (2) + u8 (1) + opcode tag (1) = 8 bytes
        }
    }
}

// OpCode Size Analysis: u8 vs u16 Decision
//
// Analysis: OpCode CANNOT fit in u8 and REQUIRES u16 for efficient storage.
// Reasoning:
// 1. OpCode variants like Call(u16), Jmp(i16), JmpIfFalse(i16) require 2-byte parameters
// 2. Individual OpCode instruction size ranges from 1-9 bytes as calculated by size_bytes()
// 3. The enum has 16 distinct variants, requiring at least 4 bits for discrimination
// 4. For efficient binary representation, u16 (2 bytes) is the minimum safe choice
// 5. Using u8 would require complex variable-length encoding and hurt performance
// 6. u16 provides sufficient range while maintaining word-alignment for fast access
//
// Decision: Use u16 for OpCode representation in bytecode format for optimal performance.

// Represents a value in the VM
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum Value {
    Nil,
    Bool(bool),
    Int(i64),      // Primary deterministic number type.
    Symbol(usize), // Index into a constant table.
    Pair(HeapPtr), // HeapPtr is a u32 index into an ObjectArena.
    Closure(HeapPtr),
    ActorId(u32),
    Capability(Capability),
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Value::Nil => write!(f, "nil"),
            Value::Bool(b) => write!(f, "{}", b),
            Value::Int(i) => write!(f, "{}", i),
            Value::Symbol(idx) => write!(f, "Symbol({})", idx),
            Value::Pair(ptr) => write!(f, "Pair({})", ptr),
            Value::Closure(ptr) => write!(f, "Closure({})", ptr),
            Value::ActorId(id) => write!(f, "Actor({})", id),
            Value::Capability(cap) => write!(f, "Capability({:?})", cap),
        }
    }
}

// Capability enum for the capability system
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Hash, Eq)]
pub enum Capability {
    // Meta-capabilities
    MetaSelfModify, // Can modify own non-core code
    MetaGrant,      // Can grant capabilities to others (dangerous)

    // Macro & Compile-time capabilities
    MacroHygienic, // Can expand hygienic macros
    MacroUnsafe,   // Can generate arbitrary syntax
    ComptimeEval,  // Can execute code at compile-time

    // I/O & External World
    IoReadSensor,    // Read from virtual sensors
    IoWriteActuator, // Write to virtual actuators
    IoNetwork,       // Network access
    IoPersist,       // Write to persistent storage

    // System
    SysCreateActor,    // Can spawn new actors
    SysTerminateActor, // Can terminate actors (including self)
    SysClock,          // Access non-deterministic time

    // Resource privileges
    ResourceExtraMemory(u64), // Additional memory quota
    ResourceExtraTime(u64),   // Additional time quota
}

impl fmt::Display for Capability {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Capability::MetaSelfModify => write!(f, "MetaSelfModify"),
            Capability::MetaGrant => write!(f, "MetaGrant"),
            Capability::MacroHygienic => write!(f, "MacroHygienic"),
            Capability::MacroUnsafe => write!(f, "MacroUnsafe"),
            Capability::ComptimeEval => write!(f, "ComptimeEval"),
            Capability::IoReadSensor => write!(f, "IoReadSensor"),
            Capability::IoWriteActuator => write!(f, "IoWriteActuator"),
            Capability::IoNetwork => write!(f, "IoNetwork"),
            Capability::IoPersist => write!(f, "IoPersist"),
            Capability::SysCreateActor => write!(f, "SysCreateActor"),
            Capability::SysTerminateActor => write!(f, "SysTerminateActor"),
            Capability::SysClock => write!(f, "SysClock"),
            Capability::ResourceExtraMemory(bytes) => write!(f, "ResourceExtraMemory({})", bytes),
            Capability::ResourceExtraTime(ms) => write!(f, "ResourceExtraTime({})", ms),
        }
    }
}

// Host function enum for FFI operations
#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum HostFunction {
    ReadSensor = 0,
    WriteActuator = 1,
    GetWallClockNs = 2,
    SpawnActor = 3,
    TerminateActor = 4,
    NetworkSend = 5,
    NetworkReceive = 6,
    PersistWrite = 7,
    PersistRead = 8,
}

// V3 Distributed Scheduling - Node and network communication types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DistributedNode {
    pub node_id: u32,
    pub address: String,
    pub capabilities: HashSet<Capability>,
    pub load_factor: f32,
    pub last_heartbeat: u64,
    pub is_active: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorMigrationRequest {
    pub actor_id: u32,
    pub source_node: u32,
    pub target_node: u32,
    pub migration_priority: u8,
    pub state_snapshot: SerializedActorState,
    pub migration_status: MigrationStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MigrationStatus {
    Pending,
    InProgress,
    Completed,
    Failed,
    Rollback,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SerializedActorState {
    pub actor_id: u32,
    pub vm_state: Vec<u8>, // Serialized VmState
    pub capabilities: Vec<Capability>,
    pub mailbox: Vec<Value>,
    pub priority: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DistributedConsensusRequest {
    pub request_id: u64,
    pub capability: Capability,
    pub requesting_actor: u32,
    pub requesting_node: u32,
    pub justification: String,
    pub votes_required: u32,
    pub votes_received: HashMap<u32, bool>, // node_id -> vote
    pub status: ConsensusStatus,
    pub created_at: u64,
    pub expires_at: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ConsensusStatus {
    Open,
    Approved,
    Denied,
    Expired,
    Cancelled,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeHeartbeat {
    pub node_id: u32,
    pub timestamp: u64,
    pub load_factor: f32,
    pub active_actors: u32,
    pub available_capabilities: Vec<Capability>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DistributedMessage {
    Heartbeat(NodeHeartbeat),
    MigrationRequest(ActorMigrationRequest),
    MigrationResponse(MigrationResponse),
    ConsensusVote(ConsensusVote),
    RemoteExecutionRequest(RemoteExecutionRequest),
    RemoteExecutionResponse(RemoteExecutionResponse),
    ErrorResponse(DistributedError),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MigrationResponse {
    pub request_id: u64,
    pub success: bool,
    pub error_message: Option<String>,
    pub actor_status: Option<ActorStatus>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActorStatus {
    pub actor_id: u32,
    pub node_id: u32,
    pub execution_state: ExecutionState,
    pub last_updated: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutionState {
    Running,
    Paused,
    Completed,
    Errored,
    Migrating,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsensusVote {
    pub request_id: u64,
    pub voting_node: u32,
    pub vote: bool,
    pub timestamp: u64,
    pub comments: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteExecutionRequest {
    pub request_id: u64,
    pub actor_id: u32,
    pub source_node: u32,
    pub target_node: u32,
    pub bytecode: Vec<OpCode>,
    pub constants: Vec<Value>,
    pub capabilities: Vec<Capability>,
    pub priority: u8,
    pub timeout: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteExecutionResponse {
    pub request_id: u64,
    pub success: bool,
    pub result: Option<Value>,
    pub error: Option<String>,
    pub execution_time: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DistributedError {
    pub error_type: String,
    pub message: String,
    pub node_id: u32,
    pub timestamp: u64,
    pub context: Option<String>,
}

impl Value {
    pub fn is_truthy(&self) -> bool {
        match self {
            Value::Nil => false,
            Value::Bool(b) => *b,
            Value::Int(i) => *i != 0,
            Value::Symbol(_) => true,
            Value::Pair(_) => true,
            Value::Closure(_) => true,
            Value::ActorId(_) => true,
            Value::Capability(_) => true,
        }
    }
}

// V2 Type System Enhancements - Type checking and validation
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Nil,
    Bool,
    Int,
    Symbol,
    Pair,
    Closure,
    ActorId,
    Capability,
    Unknown,
}

impl From<&Value> for Type {
    fn from(value: &Value) -> Self {
        match value {
            Value::Nil => Type::Nil,
            Value::Bool(_) => Type::Bool,
            Value::Int(_) => Type::Int,
            Value::Symbol(_) => Type::Symbol,
            Value::Pair(_) => Type::Pair,
            Value::Closure(_) => Type::Closure,
            Value::ActorId(_) => Type::ActorId,
            Value::Capability(_) => Type::Capability,
        }
    }
}

impl fmt::Display for Type {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Type::Nil => write!(f, "Nil"),
            Type::Bool => write!(f, "Bool"),
            Type::Int => write!(f, "Int"),
            Type::Symbol => write!(f, "Symbol"),
            Type::Pair => write!(f, "Pair"),
            Type::Closure => write!(f, "Closure"),
            Type::ActorId => write!(f, "ActorId"),
            Type::Capability => write!(f, "Capability"),
            Type::Unknown => write!(f, "Unknown"),
        }
    }
}

/// Type checker for VM operations
pub struct TypeChecker;

impl TypeChecker {
    /// Check if a value matches the expected type
    pub fn check_type(value: &Value, expected: Type) -> bool {
        let actual = Type::from(value);
        actual == expected
    }

    /// Check if a value can be used in an arithmetic operation
    pub fn check_arithmetic_operand(value: &Value) -> bool {
        matches!(value, Value::Int(_))
    }

    /// Check if a value can be used in a comparison operation
    pub fn check_comparison_operand(value: &Value) -> bool {
        matches!(value, Value::Int(_) | Value::Bool(_))
    }

    /// Check if a value can be used as a boolean
    pub fn check_boolean_operand(value: &Value) -> bool {
        matches!(value, Value::Bool(_))
    }

    /// Check if a value can be used as a capability
    pub fn check_capability_operand(value: &Value) -> bool {
        matches!(value, Value::Capability(_))
    }

    /// Check if a value can be used as an actor ID
    pub fn check_actor_id_operand(value: &Value) -> bool {
        matches!(value, Value::ActorId(_))
    }

    /// Check if a value can be used as a closure
    pub fn check_closure_operand(value: &Value) -> bool {
        matches!(value, Value::Closure(_))
    }

    /// Check if a value can be used as a pair
    pub fn check_pair_operand(value: &Value) -> bool {
        matches!(value, Value::Pair(_))
    }

    /// Get the type of a value as a string
    pub fn get_type_name(value: &Value) -> String {
        let type_ = Type::from(value);
        type_.to_string()
    }

    /// Check if types are compatible for assignment
    pub fn check_assignment_compatibility(source: &Value, target: &Value) -> bool {
        // Nil can be assigned to any type (like null in some languages)
        if matches!(source, Value::Nil) {
            return true;
        }

        // Same types are always compatible
        if Type::from(source) == Type::from(target) {
            return true;
        }

        // Int can be assigned to Bool (truthy/falsy conversion)
        if matches!(source, Value::Int(_)) && matches!(target, Value::Bool(_)) {
            return true;
        }

        // Bool can be assigned to Int (1 for true, 0 for false)
        if matches!(source, Value::Bool(_)) && matches!(target, Value::Int(_)) {
            return true;
        }

        false
    }

    /// Check if a capability operation is valid
    pub fn check_capability_operation(capability: &Capability, operation: &str) -> bool {
        // Add capability-specific validation rules
        match capability {
            Capability::MetaGrant => {
                // MetaGrant can be used for delegation operations
                operation == "grant" || operation == "revoke"
            }
            Capability::SysTerminateActor => {
                // Termination capability can only be used for termination
                operation == "terminate"
            }
            Capability::IoNetwork => {
                // Network capability can be used for network operations
                operation == "send" || operation == "receive"
            }
            _ => true, // Other capabilities have no restrictions
        }
    }
}

/// Type-safe operation result
#[derive(Debug, Clone)]
pub enum TypeSafeResult<T> {
    Success(T),
    TypeError(String),
    SafetyError(String),
}

impl<T> TypeSafeResult<T> {
    pub fn is_success(&self) -> bool {
        matches!(self, TypeSafeResult::Success(_))
    }

    pub fn unwrap(self) -> T {
        match self {
            TypeSafeResult::Success(value) => value,
            TypeSafeResult::TypeError(msg) => panic!("Type error: {}", msg),
            TypeSafeResult::SafetyError(msg) => panic!("Safety error: {}", msg),
        }
    }

    pub fn unwrap_or(self, default: T) -> T {
        match self {
            TypeSafeResult::Success(value) => value,
            _ => default,
        }
    }
}

/// Type-safe arithmetic operations
pub struct TypeSafeArithmetic;

impl TypeSafeArithmetic {
    pub fn add(lhs: &Value, rhs: &Value) -> TypeSafeResult<Value> {
        if let (Value::Int(a), Value::Int(b)) = (lhs, rhs) {
            TypeSafeResult::Success(Value::Int(a + b))
        } else {
            TypeSafeResult::TypeError(format!(
                "Cannot add {} and {}",
                TypeChecker::get_type_name(lhs),
                TypeChecker::get_type_name(rhs)
            ))
        }
    }

    pub fn sub(lhs: &Value, rhs: &Value) -> TypeSafeResult<Value> {
        if let (Value::Int(a), Value::Int(b)) = (lhs, rhs) {
            TypeSafeResult::Success(Value::Int(a - b))
        } else {
            TypeSafeResult::TypeError(format!(
                "Cannot subtract {} and {}",
                TypeChecker::get_type_name(lhs),
                TypeChecker::get_type_name(rhs)
            ))
        }
    }

    pub fn mul(lhs: &Value, rhs: &Value) -> TypeSafeResult<Value> {
        if let (Value::Int(a), Value::Int(b)) = (lhs, rhs) {
            TypeSafeResult::Success(Value::Int(a * b))
        } else {
            TypeSafeResult::TypeError(format!(
                "Cannot multiply {} and {}",
                TypeChecker::get_type_name(lhs),
                TypeChecker::get_type_name(rhs)
            ))
        }
    }

    pub fn div(lhs: &Value, rhs: &Value) -> TypeSafeResult<Value> {
        if let (Value::Int(a), Value::Int(b)) = (lhs, rhs) {
            if *b == 0 {
                TypeSafeResult::SafetyError("Division by zero".to_string())
            } else {
                TypeSafeResult::Success(Value::Int(a / b))
            }
        } else {
            TypeSafeResult::TypeError(format!(
                "Cannot divide {} and {}",
                TypeChecker::get_type_name(lhs),
                TypeChecker::get_type_name(rhs)
            ))
        }
    }

    pub fn mod_op(lhs: &Value, rhs: &Value) -> TypeSafeResult<Value> {
        if let (Value::Int(a), Value::Int(b)) = (lhs, rhs) {
            if *b == 0 {
                TypeSafeResult::SafetyError("Modulo by zero".to_string())
            } else {
                TypeSafeResult::Success(Value::Int(a % b))
            }
        } else {
            TypeSafeResult::TypeError(format!(
                "Cannot modulo {} and {}",
                TypeChecker::get_type_name(lhs),
                TypeChecker::get_type_name(rhs)
            ))
        }
    }
}

/// Type-safe comparison operations
pub struct TypeSafeComparison;

impl TypeSafeComparison {
    pub fn eq(lhs: &Value, rhs: &Value) -> TypeSafeResult<Value> {
        match (lhs, rhs) {
            (Value::Int(a), Value::Int(b)) => TypeSafeResult::Success(Value::Bool(a == b)),
            (Value::Bool(a), Value::Bool(b)) => TypeSafeResult::Success(Value::Bool(a == b)),
            (Value::Symbol(a), Value::Symbol(b)) => TypeSafeResult::Success(Value::Bool(a == b)),
            (Value::ActorId(a), Value::ActorId(b)) => TypeSafeResult::Success(Value::Bool(a == b)),
            _ => TypeSafeResult::TypeError(format!(
                "Cannot compare {} and {} for equality",
                TypeChecker::get_type_name(lhs),
                TypeChecker::get_type_name(rhs)
            )),
        }
    }

    pub fn lt(lhs: &Value, rhs: &Value) -> TypeSafeResult<Value> {
        match (lhs, rhs) {
            (Value::Int(a), Value::Int(b)) => TypeSafeResult::Success(Value::Bool(a < b)),
            _ => TypeSafeResult::TypeError(format!(
                "Cannot compare {} and {} with <",
                TypeChecker::get_type_name(lhs),
                TypeChecker::get_type_name(rhs)
            )),
        }
    }

    pub fn gt(lhs: &Value, rhs: &Value) -> TypeSafeResult<Value> {
        match (lhs, rhs) {
            (Value::Int(a), Value::Int(b)) => TypeSafeResult::Success(Value::Bool(a > b)),
            _ => TypeSafeResult::TypeError(format!(
                "Cannot compare {} and {} with >",
                TypeChecker::get_type_name(lhs),
                TypeChecker::get_type_name(rhs)
            )),
        }
    }
}

/// Type-safe capability operations
pub struct TypeSafeCapability;

impl TypeSafeCapability {
    pub fn check_capability(value: &Value, required_capability: &Capability) -> TypeSafeResult<()> {
        if let Value::Capability(actual_capability) = value {
            if actual_capability == required_capability {
                TypeSafeResult::Success(())
            } else {
                TypeSafeResult::SafetyError(format!(
                    "Capability mismatch: expected {:?}, got {:?}",
                    required_capability, actual_capability
                ))
            }
        } else {
            TypeSafeResult::TypeError(format!(
                "Expected capability, got {}",
                TypeChecker::get_type_name(value)
            ))
        }
    }

    pub fn validate_capability_operation(
        capability: &Capability,
        operation: &str,
    ) -> TypeSafeResult<()> {
        if TypeChecker::check_capability_operation(capability, operation) {
            TypeSafeResult::Success(())
        } else {
            TypeSafeResult::SafetyError(format!(
                "Capability {:?} cannot be used for operation '{}'",
                capability, operation
            ))
        }
    }
}