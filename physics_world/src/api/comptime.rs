/// Comptime execution API for Physics World
use serde::Serialize;
use std::collections::HashSet;
use std::fmt;

use crate::scheduler::{Actor, TickResult};
use crate::types::{Capability, OpCode, Value};
use crate::vm::state::VmState;

use super::{core::PhysicsWorld, integration::ResourceMetrics};

/// Special actor ID for comptime execution
const COMPTIME_ACTOR_ID: u32 = 0;

/// Comptime execution environment with capabilities and resource limits
#[derive(Debug, Clone)]
pub struct ComptimeEnv {
    /// Capabilities available at compile-time
    pub capabilities: HashSet<Capability>,
    /// Maximum execution steps to prevent infinite compilation
    pub max_steps: u64,
    /// Maximum memory allocation for comptime execution
    pub memory_limit: usize,
}

/// Result type for comptime execution
#[derive(Debug, Serialize)]
pub struct ComptimeResult {
    /// The computed result (if execution completed successfully)
    pub output: Option<Value>,
    /// Expanded code generated by macro execution (new bytecode)
    pub expanded_code: Option<Vec<OpCode>>,
    /// Computed constants for code generation
    pub computed_constants: Vec<Value>,
    /// Proof obligations for formal tier verification
    pub proof_obligations: Vec<String>,
    /// Resource usage metrics for the comptime execution
    pub metrics: ResourceMetrics,
}

/// Error types specific to comptime execution
#[derive(Debug, Serialize)]
pub enum ComptimeError {
    /// CPU step limit was exceeded during comptime execution
    CpuLimitExceeded { limit: u64, attempted: u64 },
    /// Memory limit was exceeded during comptime execution
    MemoryLimitExceeded { limit: usize, attempted: usize },
    /// Stack underflow occurred during comptime execution
    StackUnderflow,
    /// Invalid heap pointer was encountered during comptime execution
    InvalidHeapPtr,
    /// Unknown opcode was encountered during comptime execution
    UnknownOpCode,
    /// Type mismatch occurred during comptime execution
    TypeMismatch,
    /// Division by zero occurred during comptime execution
    DivisionByZero,
    /// Arithmetic overflow occurred during comptime execution
    ArithmeticOverflow,
    /// Scheduler-level error occurred during comptime execution
    SchedulerError(String),
    /// Capability-related error occurred during comptime execution
    CapabilityError(String),
}

impl fmt::Display for ComptimeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ComptimeError::CpuLimitExceeded { limit, attempted } => {
                write!(
                    f,
                    "Comptime CPU limit exceeded: attempted {} steps, limit was {}",
                    attempted, limit
                )
            }
            ComptimeError::MemoryLimitExceeded { limit, attempted } => {
                write!(
                    f,
                    "Comptime memory limit exceeded: attempted {} bytes, limit was {}",
                    attempted, limit
                )
            }
            ComptimeError::StackUnderflow => write!(f, "Comptime stack underflow"),
            ComptimeError::InvalidHeapPtr => write!(f, "Comptime invalid heap pointer"),
            ComptimeError::UnknownOpCode => write!(f, "Comptime unknown opcode"),
            ComptimeError::TypeMismatch => write!(f, "Comptime type mismatch"),
            ComptimeError::DivisionByZero => write!(f, "Comptime division by zero"),
            ComptimeError::ArithmeticOverflow => write!(f, "Comptime arithmetic overflow"),
            ComptimeError::SchedulerError(msg) => write!(f, "Comptime scheduler error: {}", msg),
            ComptimeError::CapabilityError(msg) => write!(f, "Comptime capability error: {}", msg),
        }
    }
}

pub trait ComptimeExecution {
    /// V2 Capability System - Execute code at compile-time with restricted capabilities
    /// This is the main comptime execution API that the Jue World compiler calls
    /// for macro expansion and compile-time code evaluation.
    fn execute_comptime(
        &mut self,
        bytecode: Vec<OpCode>,
        constants: Vec<Value>,
        env: ComptimeEnv, // Capabilities granted by compiler
    ) -> Result<ComptimeResult, ComptimeError>;

    /// Internal method to run a comptime actor with sandboxed execution
    fn run_comptime_actor(&mut self, actor: &mut Actor) -> Result<ComptimeResult, ComptimeError>;
}

impl ComptimeExecution for PhysicsWorld {
    /// V2 Capability System - Execute code at compile-time with restricted capabilities
    /// This is the main comptime execution API that the Jue World compiler calls
    /// for macro expansion and compile-time code evaluation.
    fn execute_comptime(
        &mut self,
        bytecode: Vec<OpCode>,
        constants: Vec<Value>,
        env: ComptimeEnv, // Capabilities granted by compiler
    ) -> Result<ComptimeResult, ComptimeError> {
        // Create a temporary actor with COMPTIME capabilities only
        let mut temp_actor = Actor {
            id: COMPTIME_ACTOR_ID,
            vm: VmState::new(
                bytecode,
                constants,
                env.max_steps,
                env.memory_limit,
                COMPTIME_ACTOR_ID,
                100,
            ),
            capabilities: env.capabilities,
            mailbox: Vec::new(),
            is_waiting: false,
            capability_requests: Vec::new(),
            parent_id: None,
            priority: 200, // High priority for comptime execution
            priority_boost: None,
        };

        // Run with special comptime scheduler
        let result = self.run_comptime_actor(&mut temp_actor);

        // Comptime execution can't send messages or affect real actors
        // But it can return:
        // 1. Expanded code (new bytecode)
        // 2. Computed constants
        // 3. Proof obligations (for formal tier)
        result
    }

    /// Internal method to run a comptime actor with sandboxed execution
    fn run_comptime_actor(&mut self, actor: &mut Actor) -> Result<ComptimeResult, ComptimeError> {
        // Add the comptime actor to the scheduler
        // We need to take ownership and move the actor into the scheduler
        // Since Actor doesn't implement Clone, we'll use a different approach
        let actor_to_add = std::mem::replace(
            actor,
            Actor {
                id: COMPTIME_ACTOR_ID,
                vm: VmState::new(Vec::new(), Vec::new(), 0, 0, COMPTIME_ACTOR_ID, 100),
                capabilities: HashSet::new(),
                mailbox: Vec::new(),
                is_waiting: false,
                capability_requests: Vec::new(),
                parent_id: None,
                priority: 128,
                priority_boost: None,
            },
        );
        self.scheduler_mut().add_actor(actor_to_add);

        // Execute the actor with strict resource limits
        let mut steps_used = 0;
        let mut memory_used = 0;

        loop {
            match self.scheduler_mut().tick() {
                Ok(tick_result) => {
                    match tick_result {
                        TickResult::ActorYielded(_) => {
                            steps_used += 1;
                            continue;
                        }
                        TickResult::ActorFinished(_, value) => {
                            steps_used += 1;
                            // Comptime execution completed successfully
                            return Ok(ComptimeResult {
                                output: Some(value),
                                expanded_code: None,
                                computed_constants: Vec::new(),
                                proof_obligations: Vec::new(),
                                metrics: ResourceMetrics {
                                    steps_used,
                                    memory_used,
                                    execution_time_ms: 0,
                                },
                            });
                        }
                        TickResult::ActorErrored(_, vm_error) => {
                            steps_used += 1;
                            // Convert VM error to comptime error
                            let error = match vm_error {
                                crate::vm::error::VmError::CpuLimitExceeded { limit, .. } => {
                                    ComptimeError::CpuLimitExceeded {
                                        limit,
                                        attempted: steps_used,
                                    }
                                }
                                crate::vm::error::VmError::MemoryLimitExceeded {
                                    limit, ..
                                } => ComptimeError::MemoryLimitExceeded {
                                    limit,
                                    attempted: memory_used,
                                },
                                crate::vm::error::VmError::StackUnderflow { .. } => {
                                    ComptimeError::StackUnderflow
                                }
                                crate::vm::error::VmError::InvalidHeapPtr { .. } => {
                                    ComptimeError::InvalidHeapPtr
                                }
                                crate::vm::error::VmError::UnknownOpCode { .. } => {
                                    ComptimeError::UnknownOpCode
                                }
                                crate::vm::error::VmError::TypeMismatch { .. } => {
                                    ComptimeError::TypeMismatch
                                }
                                crate::vm::error::VmError::DivisionByZero { .. } => {
                                    ComptimeError::DivisionByZero
                                }
                                crate::vm::error::VmError::ArithmeticOverflow { .. } => {
                                    ComptimeError::ArithmeticOverflow
                                }
                                crate::vm::error::VmError::CapabilityError {
                                    capability, ..
                                } => ComptimeError::CapabilityError(format!(
                                    "Capability error: {}",
                                    capability
                                )),
                                crate::vm::error::VmError::SerializationError {
                                    message, ..
                                } => ComptimeError::SchedulerError(format!(
                                    "Serialization error: {}",
                                    message
                                )),
                                crate::vm::error::VmError::HeapCorruption { message, .. } => {
                                    ComptimeError::SchedulerError(format!(
                                        "Heap corruption: {}",
                                        message
                                    ))
                                }
                                crate::vm::error::VmError::RecursionLimitExceeded { .. } => {
                                    ComptimeError::SchedulerError(
                                        "Recursion limit exceeded".to_string(),
                                    )
                                }
                                crate::vm::error::VmError::StackOverflow { .. } => {
                                    ComptimeError::SchedulerError(
                                        "Stack overflow".to_string(),
                                    )
                                }
                                crate::vm::error::VmError::GcDisabled => {
                                    ComptimeError::SchedulerError(
                                        "GC disabled".to_string(),
                                    )
                                }
                                crate::vm::error::VmError::HeapExhausted => {
                                    ComptimeError::SchedulerError(
                                        "Heap exhausted".to_string(),
                                    )
                                }
                                crate::vm::error::VmError::DebuggerError { message } => {
                                    ComptimeError::SchedulerError(format!(
                                        "Debugger error: {}",
                                        message
                                    ))
                                }
                            };
                            return Err(error);
                        }
                        TickResult::ActorWaitingForCapability(actor_id, capability) => {
                            // Comptime actors cannot request additional capabilities
                            // This is a security measure to prevent capability escalation
                            return Err(ComptimeError::CapabilityError(
                                "Comptime execution cannot request additional capabilities"
                                    .to_string(),
                            ));
                        }
                    }
                }
                Err(physics_error) => {
                    return Err(ComptimeError::SchedulerError(physics_error.to_string()));
                }
            }
        }
    }
}
