use crate::types::Value;
use crate::vm::error::VmError as DetailedVmError;
use crate::vm::state::{InstructionResult, VmState};
use std::collections::{HashMap, HashSet};

/// Represents a capability request from an actor
#[derive(Debug, Clone)]
pub struct CapRequest {
    pub capability: crate::types::Capability,
    pub justification: String,
    pub requested_at: u64,
    pub granted: Option<bool>,
}

/// Represents an actor in the Physics World.
pub struct Actor {
    pub id: u32,
    pub vm: VmState,
    pub mailbox: Vec<Value>, // Incoming messages
    pub is_waiting: bool,
    // V2 Capability System - Added capability state
    pub capabilities: HashSet<crate::types::Capability>,
    pub capability_requests: Vec<CapRequest>,
    pub parent_id: Option<u32>,
    // V2 Priority Scheduling - Added priority fields
    pub priority: u8,                // 0-255 range, higher = more important
    pub priority_boost: Option<u32>, // Temporary priority boost (step count)
}

/// Manages multiple actors and enforces fair, deterministic execution.
pub struct PhysicsScheduler {
    pub actors: Vec<Actor>,
    pub current_actor_index: usize,
    pub message_queues: HashMap<u32, Vec<Value>>, // External inbox per actor
    // V2 Capability System - Added capability authority state
    pub capability_audit_log: Vec<CapAuditEntry>,
    pub next_request_id: u64,
    // V2 Priority Scheduling - Added priority scheduling state
    pub use_priority_scheduling: bool, // Enable/disable priority scheduling
    pub starvation_counter: u64,       // Track steps since last low-priority actor ran
    pub starvation_threshold: u64,     // When to force run a low-priority actor
    // V2 Resource Management - Added resource tracking and management
    pub global_step_count: u64, // Global step counter for resource accounting
    pub total_memory_usage: usize, // Total memory usage across all actors
    pub memory_limit: usize,    // Global memory limit
    pub cpu_time_limit: u64,    // Global CPU time limit
    pub resource_usage_history: Vec<ResourceUsageSnapshot>, // Historical resource usage
    pub resource_quota_system: ResourceQuotaSystem, // Resource quota management
}

/// Clone implementation for PhysicsScheduler
/// Creates a new scheduler with the same configuration but empty state
impl Clone for PhysicsScheduler {
    fn clone(&self) -> Self {
        Self {
            actors: Vec::new(), // Don't clone actors - they should be managed separately
            current_actor_index: 0,
            message_queues: HashMap::new(),
            capability_audit_log: Vec::new(),
            next_request_id: self.next_request_id,
            use_priority_scheduling: self.use_priority_scheduling,
            starvation_counter: 0,
            starvation_threshold: self.starvation_threshold,
            global_step_count: 0,
            total_memory_usage: 0,
            memory_limit: self.memory_limit,
            cpu_time_limit: self.cpu_time_limit,
            resource_usage_history: Vec::new(),
            resource_quota_system: ResourceQuotaSystem {
                default_memory_quota: self.resource_quota_system.default_memory_quota,
                default_cpu_quota: self.resource_quota_system.default_cpu_quota,
                actor_quotas: HashMap::new(),
                global_memory_limit: self.resource_quota_system.global_memory_limit,
                global_cpu_limit: self.resource_quota_system.global_cpu_limit,
            },
        }
    }
}

/// Capability audit log entry for tracking capability operations
#[derive(Debug, Clone)]
pub struct CapAuditEntry {
    pub timestamp: u64,
    pub actor_id: u32,
    pub operation: CapOperation,
    pub capability: crate::types::Capability,
    pub result: CapDecisionResult,
}

/// Type of capability operation
#[derive(Debug, Clone, PartialEq)]
pub enum CapOperation {
    Request,
    Grant,
    Revoke,
    Check,
    Delegate,
    ConsensusVote,
}

/// Result of a capability operation
#[derive(Debug, Clone)]
pub enum CapDecisionResult {
    Granted,
    Denied,
    Pending,
    Error(String),
    ConsensusRequired,
    ConsensusApproved,
    ConsensusDenied,
}

/// Decision result for capability requests
#[derive(Debug, Clone)]
pub enum CapDecision {
    Granted,
    Denied,
    PendingConsensus,
}

/// Consensus vote result
#[derive(Debug, Clone)]
pub struct ConsensusVoteResult {
    pub approve: u32,
    pub deny: u32,
    pub abstain: u32,
    pub total: u32,
}

/// Result of a scheduler tick operation.
#[derive(Debug)]
pub enum TickResult {
    ActorYielded(u32),
    ActorFinished(u32, Value),
    ActorErrored(u32, DetailedVmError),
    ActorWaitingForCapability(u32, crate::types::Capability),
}

/// V2 Resource Management - Resource usage snapshot for historical tracking
#[derive(Debug, Clone)]
pub struct ResourceUsageSnapshot {
    pub timestamp: u64,
    pub global_step_count: u64,
    pub total_memory_usage: usize,
    pub total_cpu_time: u64,
    pub active_actors: u32,
    pub memory_fragmentation: f32,
}

/// V2 Resource Management - Resource quota system for fair resource allocation
#[derive(Debug, Clone)]
pub struct ResourceQuotaSystem {
    pub default_memory_quota: usize,
    pub default_cpu_quota: u64,
    pub actor_quotas: HashMap<u32, ActorResourceQuota>,
    pub global_memory_limit: usize,
    pub global_cpu_limit: u64,
}

/// V2 Resource Management - Per-actor resource quotas
#[derive(Debug, Clone)]
pub struct ActorResourceQuota {
    pub actor_id: u32,
    pub memory_quota: usize,
    pub cpu_quota: u64,
    pub memory_used: usize,
    pub cpu_used: u64,
    pub last_updated: u64,
}

/// V2 Resource Management - Resource allocation result
#[derive(Debug, Clone)]
pub enum ResourceAllocationResult {
    Success,
    QuotaExceeded,
    GlobalLimitExceeded,
    InsufficientResources,
}

/// V2 Resource Management - Resource monitoring statistics
#[derive(Debug, Clone)]
pub struct ResourceMonitoringStats {
    pub memory_usage: usize,
    pub memory_limit: usize,
    pub memory_usage_percent: f32,
    pub cpu_time_used: u64,
    pub cpu_time_limit: u64,
    pub cpu_usage_percent: f32,
    pub fragmentation_ratio: f32,
    pub active_actors: u32,
    pub waiting_actors: u32,
}

/// Error types that can occur during scheduler operations.
#[derive(Debug)]
pub enum PhysicsError {
    ActorNotFound(u32),
    SchedulerError(String),
    CapabilityError(String),
    ConsensusError(String),
}

impl std::fmt::Display for PhysicsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PhysicsError::ActorNotFound(id) => write!(f, "Actor not found: {}", id),
            PhysicsError::SchedulerError(msg) => write!(f, "Scheduler error: {}", msg),
            PhysicsError::CapabilityError(msg) => write!(f, "Capability error: {}", msg),
            PhysicsError::ConsensusError(msg) => write!(f, "Consensus error: {}", msg),
        }
    }
}

impl PhysicsScheduler {
    /// Creates a new PhysicsScheduler with empty actor list.
    pub fn new() -> Self {
        Self {
            actors: Vec::new(),
            current_actor_index: 0,
            message_queues: HashMap::new(),
            capability_audit_log: Vec::new(),
            next_request_id: 0,
            use_priority_scheduling: false, // Default to round-robin for backward compatibility
            starvation_counter: 0,
            starvation_threshold: 1000, // Default threshold to prevent starvation
            // V2 Resource Management - Initialize resource tracking
            global_step_count: 0,
            total_memory_usage: 0,
            memory_limit: usize::MAX, // No limit by default
            cpu_time_limit: u64::MAX, // No limit by default
            resource_usage_history: Vec::new(),
            resource_quota_system: ResourceQuotaSystem {
                default_memory_quota: 1024 * 1024, // 1MB default
                default_cpu_quota: 1000000,        // 1M steps default
                actor_quotas: HashMap::new(),
                global_memory_limit: usize::MAX,
                global_cpu_limit: u64::MAX,
            },
        }
    }

    /// Main execution tick. Runs the current actor until it yields, finishes, or hits a limit.
    pub fn tick(&mut self) -> Result<TickResult, PhysicsError> {
        // Check if there are any actors
        if self.actors.is_empty() {
            return Err(PhysicsError::SchedulerError(
                "No actors to schedule".to_string(),
            ));
        }

        // Select next actor based on scheduling mode
        if self.use_priority_scheduling {
            self.select_next_actor_by_priority();
        }
        // Note: For round-robin, we don't advance here - current_actor_index stays the same
        // until the actor yields/finishes/errors, then we advance in the result handling

        // Get current actor
        let current_index = self.current_actor_index;
        let actor = &mut self.actors[current_index];

        // Process any messages in the actor's mailbox first
        if !actor.mailbox.is_empty() {
            // For now, just push messages onto the stack
            // In a real implementation, this would be more sophisticated
            for message in actor.mailbox.drain(..) {
                actor.vm.stack.push(message);
            }
        }

        // Execute the actor's VM until it yields, finishes, errors, or requests a capability
        loop {
            match actor.vm.step() {
                Ok(InstructionResult::Continue) => {
                    // Continue executing
                    continue;
                }
                Ok(InstructionResult::Yield) => {
                    // Actor yielded, move to next actor
                    let actor_id = actor.id;
                    self.advance_to_next_actor();
                    return Ok(TickResult::ActorYielded(actor_id));
                }
                Ok(InstructionResult::Finished(value)) => {
                    // Actor finished, move to next actor
                    let actor_id = actor.id;
                    self.advance_to_next_actor();
                    return Ok(TickResult::ActorFinished(actor_id, value));
                }
                Ok(InstructionResult::WaitingForCapability(capability)) => {
                    // Actor is waiting for capability decision
                    let actor_id = actor.id;
                    self.advance_to_next_actor();
                    return Ok(TickResult::ActorWaitingForCapability(actor_id, capability));
                }
                Err(vm_error) => {
                    // Actor errored, move to next actor
                    let actor_id = actor.id;
                    // Convert the simple VmError to detailed VmError
                    let context = actor.vm.create_error_context();
                    let detailed_error =
                        crate::vm::error::WithContext::with_context(vm_error, context);
                    self.advance_to_next_actor();
                    return Ok(TickResult::ActorErrored(actor_id, detailed_error));
                }
            }
        }
    }

    /// Delivers a message to an actor's external queue.
    pub fn send_message(&mut self, target: u32, message: Value) {
        self.message_queues
            .entry(target)
            .or_insert_with(Vec::new)
            .push(message);
    }

    /// Advances to the next actor in round-robin fashion.
    fn advance_to_next_actor(&mut self) {
        if self.actors.is_empty() {
            self.current_actor_index = 0;
            return;
        }

        self.current_actor_index = (self.current_actor_index + 1) % self.actors.len();
    }

    /// Selects the next actor based on priority scheduling.
    fn select_next_actor_by_priority(&mut self) {
        if self.actors.is_empty() {
            self.current_actor_index = 0;
            return;
        }

        // Check if we need to prevent starvation
        if self.starvation_counter >= self.starvation_threshold {
            // Force run a low-priority actor to prevent starvation
            self.select_lowest_priority_actor();
            self.starvation_counter = 0;
            return;
        }

        // Find the highest priority actor that is ready to run
        let mut highest_priority = 0;
        let mut highest_priority_index = 0;
        let mut found_ready_actor = false;

        for (index, actor) in self.actors.iter().enumerate() {
            // Skip actors that are waiting for capabilities
            if actor.is_waiting {
                continue;
            }

            // Calculate effective priority (considering temporary boosts)
            let effective_priority = self.calculate_effective_priority(actor);

            if !found_ready_actor || effective_priority > highest_priority {
                highest_priority = effective_priority;
                highest_priority_index = index;
                found_ready_actor = true;
            }
        }

        if found_ready_actor {
            self.current_actor_index = highest_priority_index;
            // Increment starvation counter if this is a high-priority actor
            if highest_priority > 128 {
                // Consider priority > 128 as "high"
                self.starvation_counter += 1;
            }
        } else {
            // No ready actors, just advance normally
            self.advance_to_next_actor();
        }
    }

    /// Selects the lowest priority actor to prevent starvation.
    fn select_lowest_priority_actor(&mut self) {
        if self.actors.is_empty() {
            self.current_actor_index = 0;
            return;
        }

        let mut lowest_priority = u8::MAX;
        let mut lowest_priority_index = 0;
        let mut found_ready_actor = false;

        for (index, actor) in self.actors.iter().enumerate() {
            // Skip actors that are waiting for capabilities
            if actor.is_waiting {
                continue;
            }

            // Calculate effective priority (considering temporary boosts)
            let effective_priority = self.calculate_effective_priority(actor);

            if !found_ready_actor || effective_priority < lowest_priority {
                lowest_priority = effective_priority;
                lowest_priority_index = index;
                found_ready_actor = true;
            }
        }

        if found_ready_actor {
            self.current_actor_index = lowest_priority_index;
        } else {
            // No ready actors, just advance normally
            self.advance_to_next_actor();
        }
    }

    /// Calculates the effective priority of an actor, considering temporary boosts.
    fn calculate_effective_priority(&self, actor: &Actor) -> u8 {
        // Start with base priority
        let mut effective_priority = actor.priority;

        // Apply temporary priority boost if present
        if let Some(boost) = actor.priority_boost {
            // Cap the boosted priority at 255
            effective_priority = effective_priority.saturating_add(boost as u8);
            if effective_priority > 255 {
                effective_priority = 255;
            }
        }

        effective_priority
    }

    /// Adds a new actor to the scheduler.
    pub fn add_actor(&mut self, actor: Actor) {
        self.actors.push(actor);
    }

    /// Gets the current actor ID.
    pub fn current_actor_id(&self) -> Option<u32> {
        self.actors.get(self.current_actor_index).map(|a| a.id)
    }

    /// Delivers external messages to actors' mailboxes.
    pub fn deliver_external_messages(&mut self) {
        for (actor_id, messages) in self.message_queues.drain() {
            if let Some(actor) = self.actors.iter_mut().find(|a| a.id == actor_id) {
                actor.mailbox.extend(messages);
            }
        }
    }

    /// V2 Capability System - Check if an actor has a specific capability
    pub fn actor_has_capability(
        &self,
        actor_id: u32,
        capability: &crate::types::Capability,
    ) -> bool {
        if let Some(actor) = self.actors.iter().find(|a| a.id == actor_id) {
            actor.capabilities.contains(capability)
        } else {
            false
        }
    }

    /// V2 Capability System - Handle capability requests from actors
    pub fn handle_capability_request(
        &mut self,
        requester_id: u32,
        capability: crate::types::Capability,
        justification: &str,
    ) -> CapDecision {
        // Log the request
        let timestamp = self.next_request_id;
        self.next_request_id += 1;

        self.capability_audit_log.push(CapAuditEntry {
            timestamp,
            actor_id: requester_id,
            operation: CapOperation::Request,
            capability: capability.clone(),
            result: CapDecisionResult::Pending,
        });

        // Find the requesting actor
        let actor = self.actors.iter_mut().find(|a| a.id == requester_id);
        if actor.is_none() {
            self.capability_audit_log.last_mut().unwrap().result =
                CapDecisionResult::Error("Actor not found".to_string());
            return CapDecision::Denied;
        }
        let actor = actor.unwrap();

        // Check if actor already has the capability
        if actor.capabilities.contains(&capability) {
            self.capability_audit_log.last_mut().unwrap().result = CapDecisionResult::Granted;
            return CapDecision::Granted;
        }

        // Store the request in the actor's request queue
        actor.capability_requests.push(CapRequest {
            capability: capability.clone(),
            justification: justification.to_string(),
            requested_at: timestamp,
            granted: None,
        });

        // Advanced capability decision logic with delegation and consensus
        let decision = match capability {
            // Meta capabilities require special handling
            crate::types::Capability::MetaSelfModify => {
                // Only grant to actors with parent (not root actors)
                if actor.parent_id.is_some() {
                    CapDecision::Granted
                } else {
                    CapDecision::Denied
                }
            }
            crate::types::Capability::MetaGrant => {
                // MetaGrant is dangerous, require consensus
                CapDecision::PendingConsensus
            }
            // Macro capabilities
            crate::types::Capability::MacroHygienic => CapDecision::Granted,
            crate::types::Capability::MacroUnsafe => {
                // Unsafe macros require MetaGrant
                if actor
                    .capabilities
                    .contains(&crate::types::Capability::MetaGrant)
                {
                    CapDecision::Granted
                } else {
                    CapDecision::Denied
                }
            }
            crate::types::Capability::ComptimeEval => CapDecision::Granted,
            // I/O capabilities - generally safe for now
            crate::types::Capability::IoReadSensor => CapDecision::Granted,
            crate::types::Capability::IoWriteActuator => CapDecision::Granted,
            crate::types::Capability::IoNetwork => {
                // Network access requires justification
                if !justification.is_empty() {
                    CapDecision::Granted
                } else {
                    CapDecision::Denied
                }
            }
            crate::types::Capability::IoPersist => CapDecision::Granted,
            // System capabilities
            crate::types::Capability::SysCreateActor => CapDecision::Granted,
            crate::types::Capability::SysTerminateActor => {
                // Can only terminate self or children
                CapDecision::Granted
            }
            crate::types::Capability::SysClock => CapDecision::Granted,
            // Resource capabilities
            crate::types::Capability::ResourceExtraMemory(_) => CapDecision::Granted,
            crate::types::Capability::ResourceExtraTime(_) => CapDecision::Granted,
        };

        // Update the request with the decision
        if let Some(last_request) = actor.capability_requests.last_mut() {
            last_request.granted = match decision {
                CapDecision::Granted => Some(true),
                CapDecision::Denied => Some(false),
                CapDecision::PendingConsensus => None,
            };
        }

        // Log the decision
        self.capability_audit_log.last_mut().unwrap().result = match decision {
            CapDecision::Granted => CapDecisionResult::Granted,
            CapDecision::Denied => CapDecisionResult::Denied,
            CapDecision::PendingConsensus => CapDecisionResult::ConsensusRequired,
        };

        // If granted, add the capability to the actor
        if let CapDecision::Granted = decision {
            actor.capabilities.insert(capability);
        }

        decision
    }

    /// V2 Capability System - Grant a capability to an actor with delegation validation
    pub fn grant_capability(
        &mut self,
        granter_id: u32,
        target_id: u32,
        capability: crate::types::Capability,
    ) -> Result<(), PhysicsError> {
        // Find the granter actor index first
        let granter_index = self
            .actors
            .iter()
            .position(|a| a.id == granter_id)
            .ok_or(PhysicsError::ActorNotFound(granter_id))?;

        // Find the target actor index
        let target_index = self
            .actors
            .iter()
            .position(|a| a.id == target_id)
            .ok_or(PhysicsError::ActorNotFound(target_id))?;

        // Get mutable references to both actors using split_at_mut
        {
            let actors = &mut self.actors;
            let split_point = std::cmp::max(granter_index, target_index) + 1;
            let (first, second) = actors.split_at_mut(split_point);

            let (granter, target) = if granter_index < target_index {
                let granter = &first[granter_index];
                let target = &mut second[0];
                (granter, target)
            } else {
                let target = &mut first[target_index];
                let granter = &second[0];
                (granter, target)
            };

            // Check if granter has MetaGrant capability for delegation
            if !granter
                .capabilities
                .contains(&crate::types::Capability::MetaGrant)
            {
                return Err(PhysicsError::CapabilityError(
                    "Granter does not have MetaGrant capability".to_string(),
                ));
            }

            // Check if granter has the capability they're trying to delegate
            if !granter.capabilities.contains(&capability) {
                return Err(PhysicsError::CapabilityError(
                    "Granter does not have the capability to delegate".to_string(),
                ));
            }

            // Check if granter can delegate this specific capability
            if !PhysicsScheduler::can_delegate_capability(granter, &capability, target) {
                return Err(PhysicsError::CapabilityError(
                    "Granter cannot delegate this capability".to_string(),
                ));
            }

            // Log the grant operation
            self.capability_audit_log.push(CapAuditEntry {
                timestamp: self.next_request_id,
                actor_id: target_id,
                operation: CapOperation::Delegate,
                capability: capability.clone(),
                result: CapDecisionResult::Granted,
            });
            self.next_request_id += 1;

            // Add the capability
            target.capabilities.insert(capability);
        }

        Ok(())
    }

    /// V2 Capability System - Check if an actor can delegate a specific capability
    fn can_delegate_capability(
        granter: &Actor,
        capability: &crate::types::Capability,
        target: &Actor,
    ) -> bool {
        // Granter must have the capability they're trying to delegate
        if !granter.capabilities.contains(capability) {
            return false;
        }

        // Special rules for dangerous capabilities
        match capability {
            // MetaGrant can only be delegated to children or with high reputation
            crate::types::Capability::MetaGrant => {
                target.parent_id == Some(granter.id) || granter.priority > 200
            }
            // Other dangerous capabilities require consensus
            crate::types::Capability::SysTerminateActor
            | crate::types::Capability::MacroUnsafe
            | crate::types::Capability::MetaSelfModify => {
                // For now, only allow delegation to children for dangerous capabilities
                target.parent_id == Some(granter.id)
            }
            // Most capabilities can be freely delegated
            _ => true,
        }
    }

    /// V2 Capability System - Revoke a capability from an actor with validation
    pub fn revoke_capability(
        &mut self,
        revoker_id: u32,
        target_id: u32,
        capability: &crate::types::Capability,
    ) -> Result<(), PhysicsError> {
        // Find the revoker actor index first
        let revoker_index = self
            .actors
            .iter()
            .position(|a| a.id == revoker_id)
            .ok_or(PhysicsError::ActorNotFound(revoker_id))?;

        // Find the target actor index
        let target_index = self
            .actors
            .iter()
            .position(|a| a.id == target_id)
            .ok_or(PhysicsError::ActorNotFound(target_id))?;

        // Get mutable references to both actors using split_at_mut
        {
            let actors = &mut self.actors;
            let split_point = std::cmp::max(revoker_index, target_index) + 1;
            let (first, second) = actors.split_at_mut(split_point);

            let (revoker, target) = if revoker_index < target_index {
                let revoker = &first[revoker_index];
                let target = &mut second[0];
                (revoker, target)
            } else {
                let target = &mut first[target_index];
                let revoker = &second[0];
                (revoker, target)
            };

            // Check if revoker has permission to revoke this capability
            if !PhysicsScheduler::can_revoke_capability(revoker, target, capability) {
                return Err(PhysicsError::CapabilityError(
                    "Revoker does not have permission to revoke this capability".to_string(),
                ));
            }

            // Log the revoke operation
            self.capability_audit_log.push(CapAuditEntry {
                timestamp: self.next_request_id,
                actor_id: target_id,
                operation: CapOperation::Revoke,
                capability: capability.clone(),
                result: CapDecisionResult::Granted,
            });
            self.next_request_id += 1;

            // Remove the capability
            target.capabilities.remove(capability);
        }

        Ok(())
    }

    /// V2 Capability System - Check if an actor can revoke a capability
    fn can_revoke_capability(
        revoker: &Actor,
        target: &Actor,
        capability: &crate::types::Capability,
    ) -> bool {
        // Actors can always revoke their own capabilities
        if revoker.id == target.id {
            return true;
        }

        // MetaGrant holders can revoke most capabilities
        if revoker
            .capabilities
            .contains(&crate::types::Capability::MetaGrant)
        {
            // But cannot revoke MetaGrant from others unless they're the parent
            if let crate::types::Capability::MetaGrant = capability {
                return target.parent_id == Some(revoker.id);
            }
            return true;
        }

        // Parents can revoke capabilities from their children
        target.parent_id == Some(revoker.id)
    }

    /// V2 Capability System - Handle consensus voting for dangerous capabilities
    pub fn handle_consensus_vote(
        &mut self,
        voter_id: u32,
        requester_id: u32,
        capability: &crate::types::Capability,
        vote: bool, // true = approve, false = deny
    ) -> Result<CapDecision, PhysicsError> {
        // Find the voter actor
        let voter = self.actors.iter().find(|a| a.id == voter_id);
        if voter.is_none() {
            return Err(PhysicsError::ActorNotFound(voter_id));
        }
        let _voter = voter.unwrap();

        // Find the requester actor
        let requester = self.actors.iter().find(|a| a.id == requester_id);
        if requester.is_none() {
            return Err(PhysicsError::ActorNotFound(requester_id));
        }

        // Log the consensus vote
        self.capability_audit_log.push(CapAuditEntry {
            timestamp: self.next_request_id,
            actor_id: voter_id,
            operation: CapOperation::ConsensusVote,
            capability: capability.clone(),
            result: if vote {
                CapDecisionResult::Granted
            } else {
                CapDecisionResult::Denied
            },
        });
        self.next_request_id += 1;

        // Get the current consensus state for this request
        let consensus_result = self.get_consensus_state(requester_id, capability)?;

        // Check if consensus threshold is met (75% supermajority for dangerous capabilities)
        let required_approval = (consensus_result.total as f32 * 0.75).ceil() as u32;

        if consensus_result.approve >= required_approval {
            // Consensus approved - grant the capability
            if let Some(target) = self.actors.iter_mut().find(|a| a.id == requester_id) {
                target.capabilities.insert(capability.clone());

                // Update the audit log with final decision
                self.capability_audit_log.last_mut().unwrap().result =
                    CapDecisionResult::ConsensusApproved;
            }
            Ok(CapDecision::Granted)
        } else if consensus_result.deny > consensus_result.total / 2 {
            // Majority denial - deny the capability
            self.capability_audit_log.last_mut().unwrap().result =
                CapDecisionResult::ConsensusDenied;
            Ok(CapDecision::Denied)
        } else {
            // Still pending
            Ok(CapDecision::PendingConsensus)
        }
    }

    /// V2 Capability System - Get current consensus state for a capability request
    fn get_consensus_state(
        &self,
        requester_id: u32,
        capability: &crate::types::Capability,
    ) -> Result<ConsensusVoteResult, PhysicsError> {
        // Count votes from the audit log
        let mut approve = 0;
        let mut deny = 0;
        let mut abstain = 0;

        for entry in &self.capability_audit_log {
            if entry.operation == CapOperation::ConsensusVote
                && entry.actor_id == requester_id
                && entry.capability == *capability
            {
                match entry.result {
                    CapDecisionResult::Granted => approve += 1,
                    CapDecisionResult::Denied => deny += 1,
                    _ => abstain += 1,
                }
            }
        }

        // Count total eligible voters (actors with MetaGrant capability)
        let total_eligible = self
            .actors
            .iter()
            .filter(|a| {
                a.capabilities
                    .contains(&crate::types::Capability::MetaGrant)
            })
            .count() as u32;

        Ok(ConsensusVoteResult {
            approve,
            deny,
            abstain,
            total: total_eligible,
        })
    }

    /// V2 Capability System - Get capability audit log
    pub fn get_capability_audit_log(&self) -> &[CapAuditEntry] {
        &self.capability_audit_log
    }

    /// V2 Capability System - Clear capability audit log
    pub fn clear_capability_audit_log(&mut self) {
        self.capability_audit_log.clear();
    }

    // V2 Priority Scheduling - Priority Management Methods

    /// Enables priority-based scheduling.
    pub fn enable_priority_scheduling(&mut self) {
        self.use_priority_scheduling = true;
    }

    /// Disables priority-based scheduling (uses round-robin).
    pub fn disable_priority_scheduling(&mut self) {
        self.use_priority_scheduling = false;
    }

    /// Sets the priority of an actor.
    pub fn set_priority(&mut self, actor_id: u32, priority: u8) -> Result<(), PhysicsError> {
        if let Some(actor) = self.actors.iter_mut().find(|a| a.id == actor_id) {
            actor.priority = priority;
            Ok(())
        } else {
            Err(PhysicsError::ActorNotFound(actor_id))
        }
    }

    /// Gets the priority of an actor.
    pub fn get_priority(&self, actor_id: u32) -> Result<u8, PhysicsError> {
        if let Some(actor) = self.actors.iter().find(|a| a.id == actor_id) {
            Ok(actor.priority)
        } else {
            Err(PhysicsError::ActorNotFound(actor_id))
        }
    }

    /// Adjusts the priority of an actor by a delta.
    pub fn adjust_priority(&mut self, actor_id: u32, delta: i8) -> Result<u8, PhysicsError> {
        if let Some(actor) = self.actors.iter_mut().find(|a| a.id == actor_id) {
            if delta > 0 {
                actor.priority = actor.priority.saturating_add(delta as u8);
            } else {
                actor.priority = actor.priority.saturating_sub((-delta) as u8);
            }
            Ok(actor.priority)
        } else {
            Err(PhysicsError::ActorNotFound(actor_id))
        }
    }

    /// Sets a temporary priority boost for an actor.
    pub fn set_priority_boost(&mut self, actor_id: u32, boost: u32) -> Result<(), PhysicsError> {
        if let Some(actor) = self.actors.iter_mut().find(|a| a.id == actor_id) {
            actor.priority_boost = Some(boost);
            Ok(())
        } else {
            Err(PhysicsError::ActorNotFound(actor_id))
        }
    }

    /// Clears the priority boost for an actor.
    pub fn clear_priority_boost(&mut self, actor_id: u32) -> Result<(), PhysicsError> {
        if let Some(actor) = self.actors.iter_mut().find(|a| a.id == actor_id) {
            actor.priority_boost = None;
            Ok(())
        } else {
            Err(PhysicsError::ActorNotFound(actor_id))
        }
    }

    /// Sets the starvation threshold for priority scheduling.
    pub fn set_starvation_threshold(&mut self, threshold: u64) {
        self.starvation_threshold = threshold;
    }

    /// Gets the current starvation threshold.
    pub fn get_starvation_threshold(&self) -> u64 {
        self.starvation_threshold
    }

    // V2 Resource Management - Resource Management Methods

    /// Updates resource usage statistics and tracks global resource consumption.
    pub fn update_resource_usage(&mut self) {
        self.global_step_count += 1;

        // Calculate total memory usage across all actors
        let mut total_memory = 0;
        let mut active_actors = 0;
        let mut waiting_actors = 0;
        let mut total_fragmentation = 0.0;
        let mut fragmentation_count = 0;

        for actor in &self.actors {
            let memory_usage = actor.vm.memory.next_free() as usize;
            total_memory += memory_usage;
            active_actors += 1;

            if actor.is_waiting {
                waiting_actors += 1;
            }

            // Calculate fragmentation for this actor's memory
            let fragmentation = actor.vm.memory.fragmentation_ratio();
            total_fragmentation += fragmentation;
            fragmentation_count += 1;
        }

        self.total_memory_usage = total_memory;

        // Calculate average fragmentation
        let average_fragmentation = if fragmentation_count > 0 {
            total_fragmentation / fragmentation_count as f32
        } else {
            0.0
        };

        // Take a snapshot periodically (every 100 steps)
        if self.global_step_count % 100 == 0 {
            self.resource_usage_history.push(ResourceUsageSnapshot {
                timestamp: self.global_step_count,
                global_step_count: self.global_step_count,
                total_memory_usage: self.total_memory_usage,
                total_cpu_time: self.global_step_count,
                active_actors,
                memory_fragmentation: average_fragmentation,
            });

            // Limit history size to prevent unbounded growth
            if self.resource_usage_history.len() > 1000 {
                self.resource_usage_history.remove(0);
            }
        }
    }

    /// Gets current resource monitoring statistics.
    pub fn get_resource_stats(&self) -> ResourceMonitoringStats {
        let memory_usage_percent = if self.memory_limit > 0 {
            (self.total_memory_usage as f32 / self.memory_limit as f32) * 100.0
        } else {
            0.0
        };

        let cpu_usage_percent = if self.cpu_time_limit > 0 {
            (self.global_step_count as f32 / self.cpu_time_limit as f32) * 100.0
        } else {
            0.0
        };

        // Calculate average fragmentation
        let average_fragmentation = if !self.actors.is_empty() {
            let mut total_fragmentation = 0.0;
            for actor in &self.actors {
                total_fragmentation += actor.vm.memory.fragmentation_ratio();
            }
            total_fragmentation / self.actors.len() as f32
        } else {
            0.0
        };

        let active_actors = self.actors.iter().filter(|a| !a.is_waiting).count() as u32;
        let waiting_actors = self.actors.iter().filter(|a| a.is_waiting).count() as u32;

        ResourceMonitoringStats {
            memory_usage: self.total_memory_usage,
            memory_limit: self.memory_limit,
            memory_usage_percent,
            cpu_time_used: self.global_step_count,
            cpu_time_limit: self.cpu_time_limit,
            cpu_usage_percent,
            fragmentation_ratio: average_fragmentation,
            active_actors,
            waiting_actors,
        }
    }

    /// Sets global resource limits.
    pub fn set_resource_limits(&mut self, memory_limit: usize, cpu_time_limit: u64) {
        self.memory_limit = memory_limit;
        self.cpu_time_limit = cpu_time_limit;
        self.resource_quota_system.global_memory_limit = memory_limit;
        self.resource_quota_system.global_cpu_limit = cpu_time_limit;
    }

    /// Checks if global resource limits are exceeded.
    pub fn check_resource_limits(&self) -> bool {
        (self.memory_limit > 0 && self.total_memory_usage > self.memory_limit)
            || (self.cpu_time_limit > 0 && self.global_step_count > self.cpu_time_limit)
    }

    /// Allocates resources to an actor with quota checking.
    pub fn allocate_resources_to_actor(
        &mut self,
        actor_id: u32,
        memory_request: usize,
        cpu_request: u64,
    ) -> ResourceAllocationResult {
        // Check global limits first
        if self.memory_limit > 0 && self.total_memory_usage + memory_request > self.memory_limit {
            return ResourceAllocationResult::GlobalLimitExceeded;
        }

        if self.cpu_time_limit > 0 && self.global_step_count + cpu_request > self.cpu_time_limit {
            return ResourceAllocationResult::GlobalLimitExceeded;
        }

        // Get or create actor quota
        let quota = self
            .resource_quota_system
            .actor_quotas
            .entry(actor_id)
            .or_insert_with(|| ActorResourceQuota {
                actor_id,
                memory_quota: self.resource_quota_system.default_memory_quota,
                cpu_quota: self.resource_quota_system.default_cpu_quota,
                memory_used: 0,
                cpu_used: 0,
                last_updated: self.global_step_count,
            });

        // Check actor quota
        if quota.memory_used + memory_request > quota.memory_quota {
            return ResourceAllocationResult::QuotaExceeded;
        }

        if quota.cpu_used + cpu_request > quota.cpu_quota {
            return ResourceAllocationResult::QuotaExceeded;
        }

        // Allocate resources
        quota.memory_used += memory_request;
        quota.cpu_used += cpu_request;
        quota.last_updated = self.global_step_count;

        self.total_memory_usage += memory_request;

        ResourceAllocationResult::Success
    }

    /// Releases resources from an actor.
    pub fn release_resources_from_actor(
        &mut self,
        actor_id: u32,
        memory_release: usize,
        cpu_release: u64,
    ) {
        if let Some(quota) = self.resource_quota_system.actor_quotas.get_mut(&actor_id) {
            quota.memory_used = quota.memory_used.saturating_sub(memory_release);
            quota.cpu_used = quota.cpu_used.saturating_sub(cpu_release);
            quota.last_updated = self.global_step_count;

            self.total_memory_usage = self.total_memory_usage.saturating_sub(memory_release);
        }
    }

    /// Sets custom resource quotas for an actor.
    pub fn set_actor_resource_quota(
        &mut self,
        actor_id: u32,
        memory_quota: usize,
        cpu_quota: u64,
    ) -> Result<(), PhysicsError> {
        let quota = self
            .resource_quota_system
            .actor_quotas
            .entry(actor_id)
            .or_insert_with(|| ActorResourceQuota {
                actor_id,
                memory_quota: self.resource_quota_system.default_memory_quota,
                cpu_quota: self.resource_quota_system.default_cpu_quota,
                memory_used: 0,
                cpu_used: 0,
                last_updated: self.global_step_count,
            });

        quota.memory_quota = memory_quota;
        quota.cpu_quota = cpu_quota;

        Ok(())
    }

    /// Gets resource usage for a specific actor.
    pub fn get_actor_resource_usage(&self, actor_id: u32) -> Option<ActorResourceQuota> {
        self.resource_quota_system
            .actor_quotas
            .get(&actor_id)
            .cloned()
    }

    /// Gets the resource usage history.
    pub fn get_resource_usage_history(&self) -> &[ResourceUsageSnapshot] {
        &self.resource_usage_history
    }

    /// Clears resource usage history.
    pub fn clear_resource_usage_history(&mut self) {
        self.resource_usage_history.clear();
    }

    /// Triggers defragmentation for all actors if fragmentation exceeds threshold.
    pub fn auto_defragment_if_needed(&mut self, threshold: f32) {
        for actor in &mut self.actors {
            if actor.vm.memory.should_defragment()
                && actor.vm.memory.fragmentation_ratio() > threshold
            {
                let _ = actor.vm.memory.defragment(); // Ignore result for automatic defrag
            }
        }
    }
}

#[cfg(test)]
#[path = "test/scheduler_tests.rs"]
mod tests;