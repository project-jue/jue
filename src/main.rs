#!/usr/bin/env -S cargo run --bin jue
use clap::{Arg, Command};
use std::fs;
use std::io::{self, Write};
use std::process;
use std::time::Instant;

use jue_world::{compile, TrustTier};
use physics_world::{ExecutionResult, PhysicsWorld};

fn main() {
    // Initialize logging
    env_logger::init();

    // Parse command line arguments
    let matches = Command::new("jue")
        .version("0.1.0")
        .author("Project Jue Team")
        .about("Jue Language Interpreter - A capability-aware dual-interpretation language")
        .arg(
            Arg::new("file")
                .help("Jue source file to execute")
                .required(false)
                .index(1),
        )
        .arg(
            Arg::new("tier")
                .long("tier")
                .short('t')
                .help("Trust tier for execution (formal, verified, empirical, experimental)")
                .default_value("empirical")
                .value_parser(["formal", "verified", "empirical", "experimental"]),
        )
        .arg(
            Arg::new("steps")
                .long("steps")
                .short('s')
                .help("Maximum execution steps")
                .default_value("10000")
                .value_parser(clap::value_parser!(u64)),
        )
        .arg(
            Arg::new("memory")
                .long("memory")
                .short('m')
                .help("Maximum memory usage in bytes")
                .default_value("1048576") // 1MB
                .value_parser(clap::value_parser!(usize)),
        )
        .arg(
            Arg::new("debug")
                .long("debug")
                .short('d')
                .help("Enable debug output")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("print-ast")
                .long("print-ast")
                .help("Print the parsed AST and exit")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("print-bytecode")
                .long("print-bytecode")
                .help("Print the generated bytecode and exit")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("print-core")
                .long("print-core")
                .help("Print the CoreExpr representation (for Formal/Verified tiers)")
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            Arg::new("interactive")
                .long("interactive")
                .short('i')
                .help("Start interactive REPL mode")
                .action(clap::ArgAction::SetTrue),
        )
        .get_matches();

    // Handle interactive mode
    if matches.get_flag("interactive") {
        start_repl();
        return;
    }

    // Get the file path
    let file_path = matches.get_one::<String>("file").map(String::as_str);

    // Handle case where no file is provided and not in interactive mode
    if file_path.is_none() {
        eprintln!("Error: No input file specified and not in interactive mode");
        eprintln!("Usage: jue [OPTIONS] <FILE>");
        eprintln!("       jue --interactive");
        process::exit(1);
    }

    let file_path = file_path.unwrap();

    // Read the Jue source file
    let source = match fs::read_to_string(file_path) {
        Ok(content) => content,
        Err(e) => {
            eprintln!("Error reading file '{}': {}", file_path, e);
            process::exit(1);
        }
    };

    // Parse command line arguments
    let tier_str = matches.get_one::<String>("tier").unwrap();
    let tier = match tier_str.as_str() {
        "formal" => TrustTier::Formal,
        "verified" => TrustTier::Verified,
        "empirical" => TrustTier::Empirical,
        "experimental" => TrustTier::Experimental,
        _ => unreachable!(), // clap ensures this won't happen
    };

    let step_limit = *matches.get_one::<u64>("steps").unwrap();
    let memory_limit = *matches.get_one::<usize>("memory").unwrap();
    let debug = matches.get_flag("debug");
    let print_ast = matches.get_flag("print-ast");
    let print_bytecode = matches.get_flag("print-bytecode");
    let print_core = matches.get_flag("print-core");

    // Print file being executed
    println!("Executing {} with {} tier", file_path, tier_str);

    // Start timing
    let start_time = Instant::now();

    // Compile the Jue source code
    let compilation_result = match compile(&source, tier, step_limit, memory_limit) {
        Ok(result) => result,
        Err(e) => {
            eprintln!("Compilation error: {}", e);
            process::exit(1);
        }
    };

    // Print debug information if requested
    if debug {
        println!("\n=== Compilation Results ===");
        println!(
            "Bytecode length: {} instructions",
            compilation_result.bytecode.len()
        );
        println!("Constants: {}", compilation_result.constants.len());
        println!(
            "Required capabilities: {:?}",
            compilation_result.required_capabilities
        );
        println!(
            "Granted capabilities: {:?}",
            compilation_result.granted_capabilities
        );
        println!("Sandboxed: {}", compilation_result.sandboxed);
    }

    // Print AST if requested
    if print_ast {
        println!("\n=== AST ===");
        // Parse and print AST
        match jue_world::parser::parse(&source) {
            Ok(ast) => println!("{:#?}", ast),
            Err(e) => eprintln!("Error parsing AST: {}", e),
        }
        return;
    }

    // Print CoreExpr if requested (for Formal/Verified tiers)
    if print_core {
        if let Some(core_expr) = compilation_result.core_expr {
            println!("\n=== CoreExpr ===");
            println!("{}", core_expr);
        } else {
            println!("CoreExpr not available for this trust tier");
        }
        return;
    }

    // Print bytecode if requested
    if print_bytecode {
        println!("\n=== Bytecode ===");
        for (i, opcode) in compilation_result.bytecode.iter().enumerate() {
            println!("{}: {:?}", i, opcode);
        }
        return;
    }

    // Execute the compiled bytecode using Physics World
    let mut physics_world = PhysicsWorld::new();
    let execution_result = physics_world.execute_actor(
        1, // Actor ID
        compilation_result.bytecode,
        compilation_result.constants,
        compilation_result.step_limit,
        compilation_result.memory_limit,
    );

    // Print execution results
    print_execution_results(&execution_result, debug, start_time);
}

fn start_repl() {
    println!("Jue Interactive REPL (Ctrl+C to exit)");
    println!("Type Jue expressions and press Enter to evaluate");

    let mut physics_world = PhysicsWorld::new();
    let mut line = String::new();

    loop {
        print!("jue> ");
        io::stdout().flush().unwrap();

        line.clear();
        match io::stdin().read_line(&mut line) {
            Ok(0) => break, // EOF
            Ok(_) => {
                // Remove newline
                let input = line.trim();

                // Skip empty lines
                if input.is_empty() {
                    continue;
                }

                // Try to compile and execute the input
                match compile(input, TrustTier::Empirical, 1000, 1024) {
                    Ok(compilation_result) => {
                        let execution_result = physics_world.execute_actor(
                            1,
                            compilation_result.bytecode,
                            compilation_result.constants,
                            compilation_result.step_limit,
                            compilation_result.memory_limit,
                        );

                        if let Some(output) = execution_result.output {
                            println!("=> {}", output);
                        } else if let Some(error) = execution_result.error {
                            println!("Error: {}", error);
                        } else {
                            println!("=> (no output)");
                        }
                    }
                    Err(e) => {
                        println!("Compilation error: {}", e);
                    }
                }
            }
            Err(e) => {
                eprintln!("Error reading input: {}", e);
                break;
            }
        }
    }

    println!("Goodbye!");
}

fn print_execution_results(execution_result: &ExecutionResult, debug: bool, start_time: Instant) {
    println!("\n=== Execution Results ===");

    if let Some(output) = &execution_result.output {
        println!("Output: {}", output);
    } else if let Some(error) = &execution_result.error {
        println!("Error: {}", error);
    } else {
        println!("No output produced");
    }

    if debug {
        println!("\n=== Debug Information ===");
        println!("Steps used: {}", execution_result.metrics.steps_used);
        println!(
            "Memory used: {} bytes",
            execution_result.metrics.memory_used
        );
        println!("Execution time: {:?}", start_time.elapsed());

        if !execution_result.messages_sent.is_empty() {
            println!("Messages sent: {:?}", execution_result.messages_sent);
        }
    }

    // Print resource usage summary
    println!("\nResource Usage:");
    println!("  Steps: {}", execution_result.metrics.steps_used);
    println!("  Memory: {} bytes", execution_result.metrics.memory_used);
    println!("  Time: {:?}", start_time.elapsed());
}
