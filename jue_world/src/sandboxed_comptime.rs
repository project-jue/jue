use crate::error::{CompilationError, SourceLocation};
use crate::trust_tier::TrustTier;
use physics_world::types::{Capability, OpCode, Value};
use std::collections::HashSet;

/// Sandboxed compile-time execution environment with strict capability restrictions
#[derive(Debug, Clone)]
pub struct SandboxedComptimeEnv {
    /// Capabilities available in this sandboxed environment
    pub capabilities: HashSet<Capability>,
    /// Maximum execution steps allowed
    pub max_steps: u64,
    /// Maximum memory usage allowed
    pub memory_limit: usize,
    /// Current step count
    pub step_count: u64,
    /// Current memory usage
    pub memory_usage: usize,
    /// Source location for error reporting
    pub location: SourceLocation,
    /// Trust tier for capability validation
    pub trust_tier: TrustTier,
}

impl SandboxedComptimeEnv {
    /// Create a new sandboxed comptime environment with restricted capabilities
    pub fn new(tier: TrustTier, max_steps: u64, memory_limit: usize) -> Self {
        // Only grant comptime-safe capabilities based on trust tier
        let mut capabilities = tier.granted_capabilities();

        // Remove dangerous capabilities that should never be available at comptime
        capabilities.remove(&Capability::IoNetwork);
        capabilities.remove(&Capability::IoPersist);
        capabilities.remove(&Capability::SysCreateActor);
        capabilities.remove(&Capability::SysTerminateActor);

        Self {
            capabilities,
            max_steps,
            memory_limit,
            step_count: 0,
            memory_usage: 0,
            location: SourceLocation::default(),
            trust_tier: tier,
        }
    }

    /// Check if a capability is available in this sandboxed environment
    pub fn has_capability(&self, capability: &Capability) -> bool {
        self.capabilities.contains(capability)
    }

    /// Check if execution can continue within resource limits
    pub fn can_continue(&self) -> bool {
        self.step_count < self.max_steps && self.memory_usage < self.memory_limit
    }

    /// Increment step count with limit checking
    pub fn increment_step(&mut self) -> Result<(), CompilationError> {
        self.step_count += 1;
        if self.step_count > self.max_steps {
            Err(CompilationError::ComptimeError(format!(
                "Sandboxed comptime execution exceeded step limit: {}",
                self.max_steps
            )))
        } else {
            Ok(())
        }
    }

    /// Allocate memory with limit checking
    pub fn allocate_memory(&mut self, size: usize) -> Result<(), CompilationError> {
        self.memory_usage += size;
        if self.memory_usage > self.memory_limit {
            Err(CompilationError::ComptimeError(format!(
                "Sandboxed comptime execution exceeded memory limit: {}",
                self.memory_limit
            )))
        } else {
            Ok(())
        }
    }

    /// Validate capability request against sandbox restrictions
    pub fn validate_capability_request(
        &self,
        capability: &Capability,
    ) -> Result<(), CompilationError> {
        if !self.has_capability(capability) {
            Err(CompilationError::ComptimeError(format!(
                "Capability {:?} not available in sandboxed comptime environment for trust tier {:?}",
                capability, self.trust_tier
            )))
        } else {
            Ok(())
        }
    }
}

/// Sandboxed compile-time execution result
#[derive(Debug, Clone)]
pub struct SandboxedComptimeResult {
    /// Result value from execution
    pub value: Value,
    /// Generated bytecode (if any)
    pub bytecode: Vec<OpCode>,
    /// Proof obligations generated during execution
    pub proof_obligations: Vec<String>,
    /// Capability audit trail
    pub capability_audit: Vec<String>,
    /// Steps used during execution
    pub steps_used: u64,
    /// Memory used during execution
    pub memory_used: usize,
    /// Source location
    pub location: SourceLocation,
    /// Whether execution was sandboxed
    pub sandboxed: bool,
}

/// Sandboxed compile-time executor with strict capability enforcement
pub struct SandboxedComptimeExecutor {
    /// Execution environment
    pub env: SandboxedComptimeEnv,
    /// Execution stack
    pub stack: Vec<Value>,
    /// Constants pool
    pub constants: Vec<Value>,
    /// Capability audit log
    pub capability_audit: Vec<String>,
}

impl SandboxedComptimeExecutor {
    /// Create a new sandboxed comptime executor
    pub fn new(tier: TrustTier, max_steps: u64, memory_limit: usize) -> Self {
        Self {
            env: SandboxedComptimeEnv::new(tier, max_steps, memory_limit),
            stack: Vec::new(),
            constants: Vec::new(),
            capability_audit: Vec::new(),
        }
    }

    /// Execute sandboxed comptime bytecode with strict capability enforcement
    pub fn execute(
        &mut self,
        bytecode: Vec<OpCode>,
    ) -> Result<SandboxedComptimeResult, CompilationError> {
        let start_steps = self.env.step_count;
        let start_memory = self.env.memory_usage;

        for opcode in bytecode {
            self.env.increment_step()?;
            self.execute_opcode(opcode)?;
        }

        let result = SandboxedComptimeResult {
            value: self.stack.pop().unwrap_or(Value::Nil),
            bytecode: Vec::new(),          // TODO: Generate optimized bytecode
            proof_obligations: Vec::new(), // TODO: Generate proof obligations
            capability_audit: self.capability_audit.clone(),
            steps_used: self.env.step_count - start_steps,
            memory_used: self.env.memory_usage - start_memory,
            location: self.env.location.clone(),
            sandboxed: true,
        };

        Ok(result)
    }

    /// Execute a single opcode with sandbox enforcement
    fn execute_opcode(&mut self, opcode: OpCode) -> Result<(), CompilationError> {
        match opcode {
            OpCode::Nil => {
                self.stack.push(Value::Nil);
                Ok(())
            }
            OpCode::Bool(b) => {
                self.stack.push(Value::Bool(b));
                Ok(())
            }
            OpCode::Int(i) => {
                self.stack.push(Value::Int(i));
                Ok(())
            }
            OpCode::Float(f) => {
                self.stack.push(Value::Float(f));
                Ok(())
            }
            OpCode::Symbol(idx) => {
                if idx < self.constants.len() {
                    self.stack.push(self.constants[idx].clone());
                    Ok(())
                } else {
                    Err(CompilationError::ComptimeError(format!(
                        "Invalid constant index: {}",
                        idx
                    )))
                }
            }
            OpCode::LoadString(idx) => {
                // Load string from constant pool
                if idx < self.constants.len() {
                    if let Value::String(s) = &self.constants[idx] {
                        self.stack.push(Value::String(s.clone()));
                        Ok(())
                    } else {
                        Err(CompilationError::ComptimeError(format!(
                            "Expected string at constant index: {}",
                            idx
                        )))
                    }
                } else {
                    Err(CompilationError::ComptimeError(format!(
                        "Invalid string constant index: {}",
                        idx
                    )))
                }
            }
            OpCode::StrLen => {
                // Get string length
                if let Some(Value::String(s)) = self.stack.pop() {
                    self.stack.push(Value::Int(s.len() as i64));
                    Ok(())
                } else {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow or type mismatch for StrLen".to_string(),
                    ))
                }
            }
            OpCode::StrConcat => {
                // Concatenate two strings
                if let (Some(Value::String(right)), Some(Value::String(left))) =
                    (self.stack.pop(), self.stack.pop()) {
                    let mut result = left;
                    result.push_str(&right);
                    self.stack.push(Value::String(result));
                    Ok(())
                } else {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow or type mismatch for StrConcat".to_string(),
                    ))
                }
            }
            OpCode::StrIndex => {
                // Get character at index
                if let (Some(Value::Int(idx)), Some(Value::String(s))) =
                    (self.stack.pop(), self.stack.pop()) {
                    if idx >= 0 && (idx as usize) < s.len() {
                        let char_at_index = s.chars().nth(idx as usize).unwrap();
                        self.stack.push(Value::String(char_at_index.to_string()));
                    } else {
                        self.stack.push(Value::Nil); // Out of bounds
                    }
                    Ok(())
                } else {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow or type mismatch for StrIndex".to_string(),
                    ))
                }
            }
            OpCode::Dup => {
                if let Some(val) = self.stack.last().cloned() {
                    self.stack.push(val);
                    Ok(())
                } else {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                }
            }
            OpCode::Pop => {
                if self.stack.pop().is_none() {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    Ok(())
                }
            }
            OpCode::Swap => {
                if self.stack.len() < 2 {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    let len = self.stack.len();
                    self.stack.swap(len - 1, len - 2);
                    Ok(())
                }
            }
            OpCode::GetLocal(offset) => {
                // GetLocal accesses a local variable at a specific stack offset
                let position = self.stack.len() - 1 - offset as usize;
                if position >= self.stack.len() {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    let value = self.stack[position].clone();
                    self.stack.push(value);
                    Ok(())
                }
            }
            OpCode::SetLocal(offset) => {
                // SetLocal sets a local variable at a specific stack offset
                if self.stack.is_empty() {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    let position = self.stack.len() - 1 - offset as usize;
                    if position >= self.stack.len() {
                        Err(CompilationError::ComptimeError(
                            "Stack underflow".to_string(),
                        ))
                    } else {
                        let value = self.stack.pop().unwrap();
                        self.stack[position] = value;
                        Ok(())
                    }
                }
            }
            OpCode::Cons => {
                if self.stack.len() < 2 {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    // Sandboxed cons operation - create pair
                    let _second = self.stack.pop().unwrap();
                    let _first = self.stack.pop().unwrap();
                    // In sandboxed environment, we can't actually create heap objects
                    // So we push a placeholder
                    self.stack.push(Value::Nil);
                    Ok(())
                }
            }
            OpCode::Car => {
                if self.stack.pop().is_none() {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    // Sandboxed car operation
                    self.stack.push(Value::Nil);
                    Ok(())
                }
            }
            OpCode::Cdr => {
                if self.stack.pop().is_none() {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    // Sandboxed cdr operation
                    self.stack.push(Value::Nil);
                    Ok(())
                }
            }
            OpCode::Call(arg_count) => {
                if self.stack.len() < arg_count as usize + 1 {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    // Pop arguments and function
                    let _args: Vec<_> = (0..arg_count).map(|_| self.stack.pop().unwrap()).collect();
                    let _func = self.stack.pop().unwrap();

                    // In sandboxed environment, function calls are restricted
                    self.stack.push(Value::Nil);
                    Ok(())
                }
            }
            OpCode::TailCall(arg_count) => {
                if self.stack.len() < arg_count as usize + 1 {
                    Err(CompilationError::ComptimeError(
                        "Stack underflow".to_string(),
                    ))
                } else {
                    // Pop arguments and function
                    let _args: Vec<_> = (0..arg_count).map(|_| self.stack.pop().unwrap()).collect();
                    let _func = self.stack.pop().unwrap();

                    // In sandboxed environment, tail calls are restricted
                    self.stack.push(Value::Nil);
                    Ok(())
                }
            }
            OpCode::Ret => {
                // Return operation in sandboxed environment
                self.stack.push(Value::Nil);
                Ok(())
            }
            OpCode::Jmp(_) => {
                // Jump operations are restricted in sandboxed comptime
                Err(CompilationError::ComptimeError(
                    "Jump not supported in sandboxed comptime execution".to_string(),
                ))
            }
            OpCode::JmpIfFalse(_) => {
                // Conditional jumps are restricted in sandboxed comptime
                Err(CompilationError::ComptimeError(
                    "Conditional jump not supported in sandboxed comptime execution".to_string(),
                ))
            }
            OpCode::Yield => {
                // Yield is not supported in sandboxed comptime
                Err(CompilationError::ComptimeError(
                    "Yield not supported in sandboxed comptime execution".to_string(),
                ))
            }
            OpCode::Send => {
                // Send is not supported in sandboxed comptime
                Err(CompilationError::ComptimeError(
                    "Send not supported in sandboxed comptime execution".to_string(),
                ))
            }
            OpCode::Add => self.execute_binary_arithmetic(|a, b| Value::Int(a + b)),
            OpCode::Sub => self.execute_binary_arithmetic(|a, b| Value::Int(a - b)),
            OpCode::Mul => self.execute_binary_arithmetic(|a, b| Value::Int(a * b)),
            OpCode::Div => self.execute_binary_arithmetic(|a, b| Value::Int(a / b)),
            OpCode::Mod => self.execute_binary_arithmetic(|a, b| Value::Int(a % b)),
            // Float arithmetic operations - not supported in sandboxed comptime
            OpCode::FAdd | OpCode::FSub | OpCode::FMul | OpCode::FDiv => {
                return Err(CompilationError::ComptimeError(
                    "Float arithmetic not supported in sandboxed comptime execution".to_string(),
                ));
            }
            OpCode::Eq => self.execute_binary_comparison(|a, b| Value::Bool(a == b)),
            OpCode::Lt => self.execute_binary_comparison(|a, b| Value::Bool(a < b)),
            OpCode::Gt => self.execute_binary_comparison(|a, b| Value::Bool(a > b)),
            OpCode::MakeClosure(_, _) => {
                // Closure creation is restricted in sandboxed comptime
                self.stack.push(Value::Nil);
                Ok(())
            }
            OpCode::CheckStepLimit => {
                // Check step limit
                if !self.env.can_continue() {
                    Err(CompilationError::ComptimeError(
                        "Step limit exceeded".to_string(),
                    ))
                } else {
                    Ok(())
                }
            }
            OpCode::HasCap(cap_idx) => {
                // Check capability with sandbox enforcement
                if cap_idx < self.constants.len() {
                    if let Value::Capability(cap) = &self.constants[cap_idx] {
                        let has_cap = self.env.has_capability(cap);
                        self.capability_audit
                            .push(format!("Capability check: {:?} - {}", cap, has_cap));
                        self.stack.push(Value::Bool(has_cap));
                        Ok(())
                    } else {
                        Err(CompilationError::ComptimeError(
                            "Invalid capability constant".to_string(),
                        ))
                    }
                } else {
                    Err(CompilationError::ComptimeError(format!(
                        "Invalid capability index: {}",
                        cap_idx
                    )))
                }
            }
            OpCode::RequestCap(_, _) => {
                // RequestCap is not supported in sandboxed comptime
                Err(CompilationError::ComptimeError(
                    "RequestCap not supported in sandboxed comptime execution".to_string(),
                ))
            }
            OpCode::GrantCap(_, _) => {
                // GrantCap is not supported in sandboxed comptime
                Err(CompilationError::ComptimeError(
                    "GrantCap not supported in sandboxed comptime execution".to_string(),
                ))
            }
            OpCode::RevokeCap(_, _) => {
                // RevokeCap is not supported in sandboxed comptime
                Err(CompilationError::ComptimeError(
                    "RevokeCap not supported in sandboxed comptime execution".to_string(),
                ))
            }
            OpCode::HostCall { cap_idx, .. } => {
                // Host calls are restricted in sandboxed comptime
                if cap_idx < self.constants.len() {
                    if let Value::Capability(cap) = &self.constants[cap_idx] {
                        self.env.validate_capability_request(cap)?;
                        self.capability_audit
                            .push(format!("Host call with capability: {:?}", cap));
                        // Even if capability is available, host calls are restricted
                        return Err(CompilationError::ComptimeError(
                            "Host calls are restricted in sandboxed comptime execution".to_string(),
                        ));
                    }
                }
                Err(CompilationError::ComptimeError(
                    "Invalid host call in sandboxed comptime".to_string(),
                ))
            }
        }
    }

    /// Execute binary arithmetic operation with type checking
    fn execute_binary_arithmetic(
        &mut self,
        op: impl Fn(i64, i64) -> Value,
    ) -> Result<(), CompilationError> {
        if self.stack.len() < 2 {
            return Err(CompilationError::ComptimeError(
                "Stack underflow".to_string(),
            ));
        }
        let rhs = self.stack.pop().unwrap();
        let lhs = self.stack.pop().unwrap();

        match (lhs, rhs) {
            (Value::Int(a), Value::Int(b)) => {
                self.stack.push(op(a, b));
                Ok(())
            }
            _ => Err(CompilationError::ComptimeError(
                "Type mismatch for arithmetic operation".to_string(),
            )),
        }
    }

    /// Execute binary comparison operation with type checking
    fn execute_binary_comparison(
        &mut self,
        op: impl Fn(i64, i64) -> Value,
    ) -> Result<(), CompilationError> {
        if self.stack.len() < 2 {
            return Err(CompilationError::ComptimeError(
                "Stack underflow".to_string(),
            ));
        }
        let rhs = self.stack.pop().unwrap();
        let lhs = self.stack.pop().unwrap();

        match (lhs, rhs) {
            (Value::Int(a), Value::Int(b)) => {
                self.stack.push(op(a, b));
                Ok(())
            }
            _ => Err(CompilationError::ComptimeError(
                "Type mismatch for comparison operation".to_string(),
            )),
        }
    }
}

/// Sandboxed compile-time execution builder
pub struct SandboxedComptimeBuilder {
    /// Trust tier for execution
    pub trust_tier: TrustTier,
    /// Maximum execution steps
    pub max_steps: u64,
    /// Maximum memory usage
    pub memory_limit: usize,
    /// Source location
    pub location: SourceLocation,
}

impl SandboxedComptimeBuilder {
    /// Create a new sandboxed comptime builder
    pub fn new(trust_tier: TrustTier) -> Self {
        Self {
            trust_tier,
            max_steps: 1000,
            memory_limit: 1024 * 1024, // 1MB
            location: SourceLocation::default(),
        }
    }

    /// Set maximum execution steps
    pub fn with_max_steps(mut self, max_steps: u64) -> Self {
        self.max_steps = max_steps;
        self
    }

    /// Set maximum memory usage
    pub fn with_memory_limit(mut self, memory_limit: usize) -> Self {
        self.memory_limit = memory_limit;
        self
    }

    /// Set source location
    pub fn with_location(mut self, location: SourceLocation) -> Self {
        self.location = location;
        self
    }

    /// Build and execute sandboxed comptime code
    pub fn execute(
        self,
        bytecode: Vec<OpCode>,
    ) -> Result<SandboxedComptimeResult, CompilationError> {
        let mut executor =
            SandboxedComptimeExecutor::new(self.trust_tier, self.max_steps, self.memory_limit);
        executor.env.location = self.location;
        executor.execute(bytecode)
    }
}

/// Execute sandboxed compile-time code with strict capability enforcement
pub fn execute_sandboxed_comptime(
    bytecode: Vec<OpCode>,
    tier: TrustTier,
    max_steps: u64,
    memory_limit: usize,
) -> Result<SandboxedComptimeResult, CompilationError> {
    let mut executor = SandboxedComptimeExecutor::new(tier, max_steps, memory_limit);
    executor.execute(bytecode)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::trust_tier::TrustTier;

    #[test]
    fn test_sandboxed_comptime_env_creation() {
        let env = SandboxedComptimeEnv::new(TrustTier::Empirical, 100, 1024);
        assert!(env.trust_tier == TrustTier::Empirical);
        assert!(env.max_steps == 100);
        assert!(env.memory_limit == 1024);
        assert!(env.step_count == 0);
        assert!(env.memory_usage == 0);
    }

    #[test]
    fn test_sandboxed_comptime_capability_restrictions() {
        let env = SandboxedComptimeEnv::new(TrustTier::Empirical, 100, 1024);

        // Empirical tier should have IoReadSensor capability
        assert!(env.has_capability(&Capability::IoReadSensor));

        // But dangerous capabilities should be removed
        assert!(!env.has_capability(&Capability::IoNetwork));
        assert!(!env.has_capability(&Capability::SysCreateActor));
    }

    #[test]
    fn test_sandboxed_comptime_arithmetic() {
        let mut executor = SandboxedComptimeExecutor::new(TrustTier::Empirical, 100, 1024);

        // Test arithmetic operations
        let bytecode = vec![OpCode::Int(42), OpCode::Int(10), OpCode::Add];

        let result = executor.execute(bytecode);
        assert!(result.is_ok());

        let comptime_result = result.unwrap();
        assert!(comptime_result.value == Value::Int(52));
        assert!(comptime_result.sandboxed);
    }

    #[test]
    fn test_sandboxed_comptime_comparison() {
        let mut executor = SandboxedComptimeExecutor::new(TrustTier::Empirical, 100, 1024);

        // Test comparison operations
        let bytecode = vec![OpCode::Int(42), OpCode::Int(10), OpCode::Gt];

        let result = executor.execute(bytecode);
        assert!(result.is_ok());

        let comptime_result = result.unwrap();
        assert!(comptime_result.value == Value::Bool(true));
    }

    #[test]
    fn test_sandboxed_comptime_resource_limits() {
        let mut executor = SandboxedComptimeExecutor::new(TrustTier::Empirical, 2, 1024);

        // Test step limit enforcement
        let bytecode = vec![
            OpCode::Int(1),
            OpCode::Int(2),
            OpCode::Add, // This should exceed step limit
        ];

        let result = executor.execute(bytecode);
        assert!(result.is_err());
    }

    #[test]
    fn test_sandboxed_comptime_restricted_operations() {
        let mut executor = SandboxedComptimeExecutor::new(TrustTier::Empirical, 100, 1024);

        // Test that restricted operations fail
        let bytecode = vec![OpCode::Jmp(10)];

        let result = executor.execute(bytecode);
        assert!(result.is_err());
    }

    #[test]
    fn test_sandboxed_comptime_builder() {
        let builder = SandboxedComptimeBuilder::new(TrustTier::Empirical)
            .with_max_steps(50)
            .with_memory_limit(512)
            .with_location(SourceLocation::default());

        let bytecode = vec![OpCode::Int(10), OpCode::Int(20), OpCode::Add];

        let result = builder.execute(bytecode);
        assert!(result.is_ok());

        let comptime_result = result.unwrap();
        assert!(comptime_result.value == Value::Int(30));
        assert!(comptime_result.steps_used <= 50);
        assert!(comptime_result.memory_used <= 512);
    }

    #[test]
    fn test_sandboxed_comptime_capability_audit() {
        let mut executor = SandboxedComptimeExecutor::new(TrustTier::Empirical, 100, 1024);

        // Add a capability constant
        executor
            .constants
            .push(Value::Capability(Capability::IoReadSensor));

        // Test capability check with audit
        let bytecode = vec![OpCode::HasCap(0)];

        let result = executor.execute(bytecode);
        assert!(result.is_ok());

        let comptime_result = result.unwrap();
        assert!(comptime_result.value == Value::Bool(true));
        assert!(comptime_result
            .capability_audit
            .contains(&"Capability check: IoReadSensor - true".to_string()));
    }

    #[test]
    fn test_sandboxed_comptime_host_call_restriction() {
        let mut executor = SandboxedComptimeExecutor::new(TrustTier::Empirical, 100, 1024);

        // Add a capability constant
        executor
            .constants
            .push(Value::Capability(Capability::IoReadSensor));

        // Test that host calls are restricted even with valid capability
        let bytecode = vec![OpCode::HostCall {
            cap_idx: 0,
            func_id: 0,
            args: 0,
        }];

        let result = executor.execute(bytecode);
        assert!(result.is_err());
    }
}
