use crate::error::CompilationError;
use crate::macro_system::macro_expander::{expand_macros, MacroExpansionContext};
use crate::trust_tier::TrustTier;
use physics_world::types::{Capability, OpCode, Value};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Main compilation pipeline for Jue-World V2.0
///
/// This is the primary entry point for compiling Jue source code into executable bytecode.
pub fn compile(
    source: &str,
    tier: TrustTier,
    default_step_limit: u64,
    default_mem_limit: usize,
) -> Result<CompilationResult, CompilationError> {
    // 1. Parse source to AST
    let ast = crate::parser::parse(source)?;

    // 2. Expand macros (with capability checking)
    let ctx = MacroExpansionContext {
        macros: HashMap::new(),
        trust_tier: tier,
    };
    let expanded_ast = expand_macros(&ast, &ctx)?;

    // 3. Analyze capability requirements
    let required_caps = super::capability_analysis::analyze_capabilities(&expanded_ast)?;

    // 4. Verify tier allows required capabilities
    super::capability_analysis::validate_tier_capabilities(tier, &required_caps)?;

    // 5. Compile based on tier
    let result = match tier {
        TrustTier::Formal | TrustTier::Verified => {
            compile_to_core_and_verify(expanded_ast, tier, default_step_limit, default_mem_limit)
        }
        TrustTier::Empirical | TrustTier::Experimental => compile_to_physics_with_checks(
            expanded_ast,
            tier,
            default_step_limit,
            default_mem_limit,
        ),
    }?;

    Ok(result)
}

/// Compilation result containing all outputs from the compilation process
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompilationResult {
    /// Generated bytecode for Physics-World execution
    pub bytecode: Vec<OpCode>,

    /// Constants used by the bytecode
    pub constants: Vec<Value>,

    /// Maximum execution steps allowed
    pub step_limit: u64,

    /// Maximum memory usage allowed
    pub memory_limit: usize,

    /// Capabilities required by the compiled code
    pub required_capabilities: Vec<Capability>,

    /// Capabilities granted by the trust tier
    pub granted_capabilities: Vec<Capability>,

    /// Whether execution is sandboxed
    pub sandboxed: bool,

    /// Source mapping for debugging
    pub source_map: Vec<(usize, usize, String)>,
}

/// Empirical validation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EmpiricalResult {
    Passed {
        tests_run: usize,
        coverage: f64,
    },
    Failed {
        reason: String,
        failing_case: String,
    },
    NotApplicable,
}

/// Compile to Core-World for Formal/Verified tiers
fn compile_to_core_and_verify(
    _ast: crate::ast::AstNode,
    _tier: TrustTier,
    _step_limit: u64,
    _mem_limit: usize,
) -> Result<CompilationResult, CompilationError> {
    // Placeholder: Core-World compilation not yet implemented
    // For now, fall back to physics compilation
    compile_to_physics_with_checks(_ast, _tier, _step_limit, _mem_limit)
}

/// Compile to Physics-World for Empirical/Experimental tiers
fn compile_to_physics_with_checks(
    ast: crate::ast::AstNode,
    tier: TrustTier,
    step_limit: u64,
    mem_limit: usize,
) -> Result<CompilationResult, CompilationError> {
    // Use the physics_compiler for all compilation for now
    let (bytecode, constants) =
        crate::physics_integration::physics_compiler::compile_to_physics_world(&ast, tier)?;

    // Analyze required capabilities for audit trail
    let required_capabilities: Vec<Capability> =
        super::capability_analysis::analyze_capabilities(&ast)?
            .into_iter()
            .collect();

    Ok(CompilationResult {
        bytecode,
        constants,
        step_limit,
        memory_limit: mem_limit,
        required_capabilities,
        granted_capabilities: tier.granted_capabilities().into_iter().collect(),
        sandboxed: tier == TrustTier::Experimental,
        source_map: Vec::new(),
    })
}
