use crate::error::{CapabilityViolation, CompilationError, SourceLocation, SourceMap};
use crate::trust_tier::TrustTier;
use core_world::core_expr::CoreExpr;
use core_world::proof_checker::Proof;
use physics_world::types::{Capability, OpCode, Value};
use serde::{Deserialize, Serialize};
/// Main compilation pipeline for Jue-World V2.0
use std::collections::HashSet;

/// Compilation result containing all outputs from the compilation process
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompilationResult {
    /// Generated bytecode for Physics-World execution
    pub bytecode: Vec<OpCode>,
    /// Constants used by the bytecode
    pub constants: Vec<Value>,
    /// Maximum execution steps allowed
    pub step_limit: u64,
    /// Maximum memory usage allowed
    pub memory_limit: usize,

    /// Formal path results (for Formal/Verified tiers)
    pub core_proof: Option<Proof>,
    pub core_expr: Option<CoreExpr>,

    /// Capability information
    pub required_capabilities: Vec<Capability>,
    pub granted_capabilities: Vec<Capability>,

    /// Empirical path results
    pub empirical_check: EmpiricalResult,
    pub sandboxed: bool,

    /// Debug information
    pub source_map: SourceMap,
    pub capability_audit: Vec<CapabilityCheck>,
}

/// Empirical validation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EmpiricalResult {
    /// Tests passed with coverage information
    Passed { tests_run: usize, coverage: f64 },
    /// Tests failed with reason
    Failed {
        reason: String,
        failing_case: String,
    },
    /// No empirical validation performed
    NotApplicable,
}

/// Capability check information for audit trail
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CapabilityCheck {
    /// Source location of the check
    pub location: SourceLocation,
    /// Capability being checked
    pub capability: Capability,
    /// Type of check performed
    pub check_type: CheckType,
}

/// Type of capability check
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum CheckType {
    /// Verified at compile time
    Static,
    /// Inserted opcode check
    Runtime,
    /// Covered by formal proof
    Proof,
}

/// Main compilation function - the public API for Jue-World
pub fn compile(
    source: &str,
    tier: TrustTier,
    default_step_limit: u64,
    default_mem_limit: usize,
) -> Result<CompilationResult, CompilationError> {
    // 1. Parse source to AST
    let ast = crate::parser::parse(source)?;

    // 2. Expand macros (with capability checking)
    let expanded_ast = crate::macro_system::expand_macros(ast, tier)?;

    // 3. Analyze capability requirements
    let required_caps = analyze_capabilities(&expanded_ast)?;

    // 4. Verify tier allows required capabilities
    validate_tier_capabilities(tier, &required_caps)?;

    // 5. Based on tier, choose compilation path
    let result = match tier {
        TrustTier::Formal | TrustTier::Verified => {
            compile_to_core_and_verify(expanded_ast, tier, default_step_limit, default_mem_limit)
        }
        TrustTier::Empirical | TrustTier::Experimental => compile_to_physics_with_checks(
            expanded_ast,
            tier,
            default_step_limit,
            default_mem_limit,
        ),
    }?;

    // 6. Package results with capability audit trail
    Ok(result)
}

/// Analyze capability requirements from AST
fn analyze_capabilities(ast: &crate::ast::AstNode) -> Result<Vec<Capability>, CompilationError> {
    // TODO: Implement capability analysis
    Ok(Vec::new())
}

/// Validate that tier allows required capabilities
fn validate_tier_capabilities(
    tier: TrustTier,
    required_caps: &[Capability],
) -> Result<(), CompilationError> {
    let granted_caps = tier.granted_capabilities();

    for cap in required_caps {
        if !granted_caps.contains(cap) {
            return Err(CompilationError::CapabilityError(CapabilityViolation {
                required: cap.clone(),
                tier,
                location: SourceLocation::default(), // TODO: Get actual location
                suggestion: format!(
                    "This capability is not available in {:?} tier. Consider using a higher trust tier.",
                    tier
                ),
            }));
        }
    }

    Ok(())
}

/// Compile to Core-World for Formal/Verified tiers
fn compile_to_core_and_verify(
    ast: crate::ast::AstNode,
    tier: TrustTier,
    step_limit: u64,
    mem_limit: usize,
) -> Result<CompilationResult, CompilationError> {
    // TODO: Implement Core-World compilation path
    // 1. Compile AST to CoreExpr
    // 2. Generate proof obligations
    // 3. Verify proofs using Core-World
    // 4. Generate verified bytecode

    Ok(CompilationResult {
        bytecode: Vec::new(),
        constants: Vec::new(),
        step_limit,
        memory_limit: mem_limit,
        core_proof: None,
        core_expr: None,
        required_capabilities: Vec::new(),
        granted_capabilities: tier.granted_capabilities().into_iter().collect(),
        empirical_check: EmpiricalResult::NotApplicable,
        sandboxed: false,
        source_map: SourceMap::new(),
        capability_audit: Vec::new(),
    })
}

/// Compile to Physics-World for Empirical/Experimental tiers
fn compile_to_physics_with_checks(
    ast: crate::ast::AstNode,
    tier: TrustTier,
    step_limit: u64,
    mem_limit: usize,
) -> Result<CompilationResult, CompilationError> {
    // TODO: Implement Physics-World compilation path
    // 1. Compile AST to bytecode
    // 2. Insert runtime capability checks
    // 3. For experimental tier, add sandbox wrapper
    // 4. Run empirical validation tests

    Ok(CompilationResult {
        bytecode: Vec::new(),
        constants: Vec::new(),
        step_limit,
        memory_limit: mem_limit,
        core_proof: None,
        core_expr: None,
        required_capabilities: Vec::new(),
        granted_capabilities: tier.granted_capabilities().into_iter().collect(),
        empirical_check: EmpiricalResult::NotApplicable,
        sandboxed: tier == TrustTier::Experimental,
        source_map: SourceMap::new(),
        capability_audit: Vec::new(),
    })
}

#[cfg(test)]
#[path = "test/compiler.rs"]
mod tests;
