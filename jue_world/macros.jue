;; Jue Macros
;; This file contains the macro system implementation for Jue language
;; Expands macros into core syntax with proof attachments

;; Import CoreExpr and proof functions from Core-World
(import core_world::core_expr::CoreExpr)
(import core_world::proof_checker::{verify_proof, attach_proof})

;; Define macro definition structure
(define-type MacroDef
  (Macro name params body))

;; Global macro environment
(define *macro-environment* (make-hash-table))

;; Register built-in macros
(define (register-builtin-macros)
  "Register built-in macro definitions"
  (hash-table-set! *macro-environment* 'when
    (Macro 'when '(cond body)
      '(If cond body (Literal #void))))

  (hash-table-set! *macro-environment* 'unless
    (Macro 'unless '(cond body)
      '(If cond (Literal #void) body)))

  (hash-table-set! *macro-environment* 'and
    (Macro 'and '(a b)
      '(If a b #f)))

  (hash-table-set! *macro-environment* 'or
    (Macro 'or '(a b)
      '(If a a b)))

  (hash-table-set! *macro-environment* 'let*
    (Macro 'let* '(bindings body)
      '(let ((expand-nested-lets bindings body))
         body)))

  (hash-table-set! *macro-environment* 'cond
    (Macro 'cond '(clauses)
      '(expand-cond-clauses clauses))))

;; Expand macro expression
;; Expected Output: Expanded AST
;; Proof Obligation: Attach proof per expansion
;; Unit Test Specification: Test match/case expansions; ensure `to_core` valid
(define (expand-macro name args)
  "Expand macro expression with proof attachment"
  (let ((macro-def (hash-table-get *macro-environment* name)))
    (if (not macro-def)
        (throw (format "Unknown macro: ~a" name)))

    (let ((expanded (apply-macro macro-def args)))
      (attach-macro-proof name args expanded))))

;; Apply macro transformation
(define (apply-macro macro-def args)
  "Apply macro transformation to arguments"
  (match macro-def
    ((Macro name params body)
     (if (not (= (length params) (length args)))
         (throw (format "Macro ~a expects ~a args, got ~a" name (length params) (length args))))

     ;; Create substitution mapping
     (let ((subst (make-hash-table)))
       (for-each (lambda (param arg index)
                   (hash-table-set! subst param arg))
                 params args (range 0 (length params)))

       ;; Expand the body with substitutions
       (expand-macro-body body subst)))))

;; Expand macro body with substitutions
(define (expand-macro-body body subst)
  "Expand macro body with variable substitutions"
  (match body
    ((Var symbol)
     (if (hash-table-has? subst symbol)
         (hash-table-get subst symbol)
         body))
    ((Lam var body-expr)
     (Lam var (expand-macro-body body-expr subst)))
    ((App func arg)
     (App (expand-macro-body func subst) (expand-macro-body arg subst)))
    ((Literal value) body)
    ((Let var value body-expr)
     (Let var (expand-macro-body value subst) (expand-macro-body body-expr subst)))
    ((If cond then else)
     (If (expand-macro-body cond subst)
         (expand-macro-body then subst)
         (expand-macro-body else subst)))
    ((list . elements)
     (map (lambda (elem) (expand-macro-body elem subst)) elements))
    (else body)))

;; Attach macro expansion proof
(define (attach-macro-proof name args expanded)
  "Attach proof that macro expansion is correct"
  (let ((proof (generate-macro-proof name args expanded)))
    (format "Macro expansion: (~a ~a) â†’ ~a with proof ~a"
            name args expanded proof)))

;; Generate macro expansion proof
(define (generate-macro-proof name args expanded)
  "Generate formal proof of macro expansion correctness"
  ;; This would be a formal proof in real implementation
  (format "Proof: Macro ~a with args ~a expands to ~a" name args expanded))

;; Expand nested let bindings for let* macro
(define (expand-nested-lets bindings body)
  "Expand nested let bindings for let* macro"
  (if (null? bindings)
      body
      (let ((binding (car bindings)))
        (Let (car binding) (cadr binding) (expand-nested-lets (cdr bindings) body)))))

;; Expand cond clauses
(define (expand-cond-clauses clauses)
  "Expand cond clauses to nested if expressions"
  (if (null? clauses)
      (Literal #void)
      (let ((clause (car clauses)))
        (if (null? (cdr clauses))
            ;; Last clause
            (If (car clause) (cadr clause) (Literal #void))
            ;; Not last clause
            (If (car clause) (cadr clause) (expand-cond-clauses (cdr clauses)))))))

;; Define macro for pattern matching
(define-macro (match expr clauses)
  "Pattern matching macro"
  (expand-match expr clauses))

;; Expand match expression
(define (expand-match expr clauses)
  "Expand match expression to nested conditionals"
  (if (null? clauses)
      (throw "Match failed - no matching clause")
      (let ((clause (car clauses))
            (pattern (car clause))
            (result (cadr clause)))
        (If (match-pattern expr pattern) result (expand-match expr (cdr clauses))))))

;; Pattern matching helper
(define (match-pattern expr pattern)
  "Check if expression matches pattern"
  (match pattern
    ('_ #t) ; Wildcard matches anything
    ((Var symbol) (equal? expr (Var symbol)))
    ((Literal value) (equal? expr (Literal value)))
    (else (equal? expr pattern))))

;; Define macro for list operations
(define-macro (list . elements)
  "List construction macro"
  (expand-list-construction elements))

;; Expand list construction
(define (expand-list-construction elements)
  "Expand list construction to nested cons cells"
  (if (null? elements)
      (Var 'nil)
      (App (App (Var 'cons) (car elements)) (expand-list-construction (cdr elements)))))

;; Define macro for function composition
(define-macro (compose . functions)
  "Function composition macro"
  (expand-function-composition functions))

;; Expand function composition
(define (expand-function-composition functions)
  "Expand function composition to nested lambda"
  (if (null? functions)
      (Lam 'x (Var 'x))
      (if (null? (cdr functions))
          (car functions)
          (Lam 'x (App (expand-function-composition (cdr functions))
                       (App (car functions) (Var 'x)))))))

;; Macro for creating closures with multiple arguments
(define-macro (lambda args . body)
  "Multi-argument lambda macro"
  (expand-multi-arg-lambda args body))

;; Expand multi-argument lambda
(define (expand-multi-arg-lambda args body)
  "Expand multi-argument lambda to nested single-arg lambdas"
  (if (null? args)
      (car body)
      (Lam (car args) (expand-multi-arg-lambda (cdr args) body))))

;; Unit tests for macro system
(define (run-macro-tests)
  "Run unit tests for macro functionality"
  (let ((passed 0)
        (failed 0))

    ;; Initialize macro environment
    (register-builtin-macros)

    ;; Test when macro
    (try
      (let ((expr (expand-macro 'when '(#t (Literal 42))))
            (expected (If #t (Literal 42) (Literal #void))))
        (if (equal? expr expected)
            (set! passed (+ passed 1))
            (set! failed (+ failed 1))))
      (catch (error)
        (set! failed (+ failed 1))))

    ;; Test unless macro
    (try
      (let ((expr (expand-macro 'unless '(#f (Literal 42))))
            (expected (If #f (Literal #void) (Literal 42))))
        (if (equal? expr expected)
            (set! passed (+ passed 1))
            (set! failed (+ failed 1))))
      (catch (error)
        (set! failed (+ failed 1))))

    ;; Test and macro
    (try
      (let ((expr (expand-macro 'and '(#t #f)))
            (expected (If #t #f #f)))
        (if (equal? expr expected)
            (set! passed (+ passed 1))
            (set! failed (+ failed 1))))
      (catch (error)
        (set! failed (+ failed 1))))

    ;; Test or macro
    (try
      (let ((expr (expand-macro 'or '(#f #t)))
            (expected (If #f #f #t)))
        (if (equal? expr expected)
            (set! passed (+ passed 1))
            (set! failed (+ failed 1))))
      (catch (error)
        (set! failed (+ failed 1))))

    ;; Test list macro
    (try
      (let ((expr (expand-macro 'list '(1 2 3)))
            (expected (App (App (Var 'cons) 1) (App (App (Var 'cons) 2) (App (App (Var 'cons) 3) (Var 'nil))))))
        (if (equal? expr expected)
            (set! passed (+ passed 1))
            (set! failed (+ failed 1))))
      (catch (error)
        (set! failed (+ failed 1))))

    ;; Test lambda macro
    (try
      (let ((expr (expand-macro 'lambda '(x y) (App (Var x) (Var y))))
            (expected (Lam 'x (Lam 'y (App (Var x) (Var y))))))
        (if (equal? expr expected)
            (set! passed (+ passed 1))
            (set! failed (+ failed 1))))
      (catch (error)
        (set! failed (+ failed 1))))

    (format "Macro tests: ~a passed, ~a failed" passed failed)))

;; Run tests when module loads
(register-builtin-macros)
(run-macro-tests)
