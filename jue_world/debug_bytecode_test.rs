use jue_world::integration::physics::compile_to_physics_world;
use jue_world::parser::parse;
use jue_world::trust_tier::TrustTier;

fn main() {
    // Test simple factorial
    let factorial_source = r#"
        (let ((fact (lambda (n)
                      (if (<= n 1)
                          1
                          (* n (fact (- n 1)))))))
          (fact 5))
    "#;

    println!("=== Debugging Factorial Compilation ===");
    println!("Source: {}", factorial_source);

    // Parse
    let ast = match parse(factorial_source) {
        Ok(parsed_ast) => {
            println!("✅ Parsing successful");
            parsed_ast
        }
        Err(e) => {
            println!("❌ Parsing failed: {:?}", e);
            return;
        }
    };

    // Compile
    let (bytecode, string_constants) = match compile_to_physics_world(&ast, TrustTier::Empirical) {
        Ok((bytecode, constants)) => {
            println!("✅ Compilation successful");
            println!("Bytecode length: {}", bytecode.len());
            println!("String constants: {:?}", string_constants);
            println!("\n=== Generated Bytecode ===");
            for (i, op) in bytecode.iter().enumerate() {
                println!("{}: {:?}", i, op);
            }
            (bytecode, constants)
        }
        Err(e) => {
            println!("❌ Compilation failed: {:?}", e);
            return;
        }
    };

    println!("\n=== Expected Flow ===");
    println!("1. Int(0) - placeholder for fact");
    println!("2. Int(1) - placeholder for factorial function");
    println!("3. GetLocal(1) - get fact from local");
    println!("4. Int(5) - argument");
    println!("5. Call(1) - call fact with 1 argument");
    println!("... actual factorial logic ...");
}
