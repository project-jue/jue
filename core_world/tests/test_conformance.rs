use core_world::{
    core_expr::{app, lam, var},
    core_kernel::{alpha_equiv, beta_reduce, normalize},
    proof_checker::{prove_beta, verify},
};

// Test 1: β-Reduction (Call-by-Name)
#[test]
fn beta_reduction_cbn() {
    // (λx. x) y  →  y
    let id = lam(var(0)); // λ.0
    let app_expr = app(id, var(1)); // (λ.0) 1
    let reduced = beta_reduce(app_expr);
    assert_eq!(reduced, var(1)); // Should be 1
}

// Test 2: α-Equivalence
#[test]
fn alpha_equivalence_basic() {
    // λx.x should be α-equivalent to λy.y (both are λ.0)
    let lam1 = lam(var(0));
    let lam2 = lam(var(0));
    assert!(alpha_equiv(lam1, lam2));
}

// Test 3: Normalization (Church numeral 2)
#[test]
fn church_numeral_normalization() {
    // λf.λx. f (f x)  should normalize to itself (no redex)
    let church_two = lam(lam(app(var(1), app(var(1), var(0)))));
    let normalized = normalize(church_two.clone());
    assert!(alpha_equiv(church_two, normalized));
}

// Test 4: Proof Verification (Critical)
#[test]
fn proof_verification_cycle() {
    // For any expression, the proof generated by `prove_beta`
    // must be verifiable by `verify`.
    let expr = app(lam(var(0)), var(42)); // (λ.0) 42
    let proof = prove_beta(expr.clone());
    let result = verify(&proof);
    assert!(result.is_ok()); // Must return true
}
